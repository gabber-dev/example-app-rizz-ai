/* tslint:disable */
/* eslint-disable */
/**
 * Session API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiV1SessionListGet200Response
 */
export interface ApiV1SessionListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionListGet200Response
     */
    'total_count': number;
    /**
     * The array of sessions.
     * @type {Array<Session>}
     * @memberof ApiV1SessionListGet200Response
     */
    'values': Array<Session>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdMessagesGet200Response
 */
export interface ApiV1SessionSessionIdMessagesGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'total_count': number;
    /**
     * The array of session timeline items.
     * @type {Array<SessionMessage>}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'values': Array<SessionMessage>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdPutRequest
 */
export interface ApiV1SessionSessionIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionSessionIdPutRequest
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdPutRequest
     */
    'voice_override'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdTimelineGet200Response
 */
export interface ApiV1SessionSessionIdTimelineGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'next_page'?: string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'total_count'?: number;
    /**
     * The array of session timeline items.
     * @type {Array<SessionTimelineItem>}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'values'?: Array<SessionTimelineItem>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200Response
 */
export interface ApiV1SessionStartPost200Response {
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseSession}
     * @memberof ApiV1SessionStartPost200Response
     */
    'session': ApiV1SessionStartPost200ResponseSession;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponsePersona}
     * @memberof ApiV1SessionStartPost200Response
     */
    'persona'?: ApiV1SessionStartPost200ResponsePersona;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseScenario}
     * @memberof ApiV1SessionStartPost200Response
     */
    'scenario'?: ApiV1SessionStartPost200ResponseScenario;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseConnectionDetails}
     * @memberof ApiV1SessionStartPost200Response
     */
    'connection_details': ApiV1SessionStartPost200ResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseConnectionDetails
 */
export interface ApiV1SessionStartPost200ResponseConnectionDetails {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseConnectionDetails
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseConnectionDetails
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponsePersona
 */
export interface ApiV1SessionStartPost200ResponsePersona {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'gender'?: ApiV1SessionStartPost200ResponsePersonaGenderEnum;
    /**
     * 
     * @type {Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'tags'?: Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'voice': string;
}

export const ApiV1SessionStartPost200ResponsePersonaGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type ApiV1SessionStartPost200ResponsePersonaGenderEnum = typeof ApiV1SessionStartPost200ResponsePersonaGenderEnum[keyof typeof ApiV1SessionStartPost200ResponsePersonaGenderEnum];

/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponsePersonaTagsInner
 */
export interface ApiV1SessionStartPost200ResponsePersonaTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersonaTagsInner
     */
    'human_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersonaTagsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseScenario
 */
export interface ApiV1SessionStartPost200ResponseScenario {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseSession
 */
export interface ApiV1SessionStartPost200ResponseSession {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'state': ApiV1SessionStartPost200ResponseSessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'time_limit_s': number;
}

export const ApiV1SessionStartPost200ResponseSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type ApiV1SessionStartPost200ResponseSessionStateEnum = typeof ApiV1SessionStartPost200ResponseSessionStateEnum[keyof typeof ApiV1SessionStartPost200ResponseSessionStateEnum];

/**
 * @type ApiV1SessionStartPostRequest
 * @export
 */
export type ApiV1SessionStartPostRequest = ApiV1SessionStartPostRequestOneOf | ApiV1SessionStartPostRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOf
 */
export interface ApiV1SessionStartPostRequestOneOf {
    /**
     * 
     * @type {Array<ApiV1SessionStartPostRequestOneOfHistoryInner>}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'history'?: Array<ApiV1SessionStartPostRequestOneOfHistoryInner>;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOf1
 */
export interface ApiV1SessionStartPostRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'scenario'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOfHistoryInner
 */
export interface ApiV1SessionStartPostRequestOneOfHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'role': ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum;
}

export const ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum = typeof ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum[keyof typeof ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum];

/**
 * 
 * @export
 * @interface AssistantMessage
 */
export interface AssistantMessage {
    /**
     * 
     * @type {AssistantMessageContent}
     * @memberof AssistantMessage
     */
    'content': AssistantMessageContent;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof AssistantMessage
     */
    'refusal'?: string;
    /**
     * The role of the messages author, in this case `assistant`.
     * @type {string}
     * @memberof AssistantMessage
     */
    'role': AssistantMessageRoleEnum;
}

export const AssistantMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type AssistantMessageRoleEnum = typeof AssistantMessageRoleEnum[keyof typeof AssistantMessageRoleEnum];

/**
 * @type AssistantMessageContent
 * The contents of the assistant message. 
 * @export
 */
export type AssistantMessageContent = Array<AssistantMessageContentOneOfInner> | string;

/**
 * @type AssistantMessageContentOneOfInner
 * @export
 */
export type AssistantMessageContentOneOfInner = RefusalContentPart | TextContentPart;

/**
 * 
 * @export
 * @interface AudioContentPart
 */
export interface AudioContentPart {
    /**
     * Audio content type.
     * @type {string}
     * @memberof AudioContentPart
     */
    'type': AudioContentPartTypeEnum;
    /**
     * 
     * @type {AudioContentPartInputAudio}
     * @memberof AudioContentPart
     */
    'input_audio': AudioContentPartInputAudio;
}

export const AudioContentPartTypeEnum = {
    InputAudio: 'input_audio'
} as const;

export type AudioContentPartTypeEnum = typeof AudioContentPartTypeEnum[keyof typeof AudioContentPartTypeEnum];

/**
 * 
 * @export
 * @interface AudioContentPartInputAudio
 */
export interface AudioContentPartInputAudio {
    /**
     * Base64 encoded audio data.
     * @type {string}
     * @memberof AudioContentPartInputAudio
     */
    'data': string;
    /**
     * The format of the audio data.
     * @type {string}
     * @memberof AudioContentPartInputAudio
     */
    'format': AudioContentPartInputAudioFormatEnum;
}

export const AudioContentPartInputAudioFormatEnum = {
    Wav: 'wav',
    Mp3: 'mp3',
    Ogg: 'ogg'
} as const;

export type AudioContentPartInputAudioFormatEnum = typeof AudioContentPartInputAudioFormatEnum[keyof typeof AudioContentPartInputAudioFormatEnum];

/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape. 
 * @export
 * @interface ChatCompletions200Response
 */
export interface ChatCompletions200Response {
    /**
     * A list of chat completion choices.
     * @type {Array<ChatCompletions200ResponseChoicesInner>}
     * @memberof ChatCompletions200Response
     */
    'choices': Array<ChatCompletions200ResponseChoicesInner>;
    /**
     * The model used for completion.
     * @type {string}
     * @memberof ChatCompletions200Response
     */
    'model': string;
    /**
     * 
     * @type {ChatCompletions200ResponseGabber}
     * @memberof ChatCompletions200Response
     */
    'gabber'?: ChatCompletions200ResponseGabber;
}
/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 * @export
 * @interface ChatCompletions200Response1
 */
export interface ChatCompletions200Response1 {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     * @type {string}
     * @memberof ChatCompletions200Response1
     */
    'id': string;
    /**
     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
     * @type {Array<ChatCompletions200Response1ChoicesInner>}
     * @memberof ChatCompletions200Response1
     */
    'choices': Array<ChatCompletions200Response1ChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     * @type {number}
     * @memberof ChatCompletions200Response1
     */
    'created': number;
    /**
     * The model to generate the completion.
     * @type {string}
     * @memberof ChatCompletions200Response1
     */
    'model': string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     * @type {string}
     * @memberof ChatCompletions200Response1
     */
    'object': ChatCompletions200Response1ObjectEnum;
    /**
     * 
     * @type {ChatCompletions200Response1Gabber}
     * @memberof ChatCompletions200Response1
     */
    'gabber'?: ChatCompletions200Response1Gabber;
}

export const ChatCompletions200Response1ObjectEnum = {
    ChatCompletionChunk: 'chat.completion.chunk'
} as const;

export type ChatCompletions200Response1ObjectEnum = typeof ChatCompletions200Response1ObjectEnum[keyof typeof ChatCompletions200Response1ObjectEnum];

/**
 * 
 * @export
 * @interface ChatCompletions200Response1ChoicesInner
 */
export interface ChatCompletions200Response1ChoicesInner {
    /**
     * 
     * @type {ChatCompletions200Response1ChoicesInnerDelta}
     * @memberof ChatCompletions200Response1ChoicesInner
     */
    'delta': ChatCompletions200Response1ChoicesInnerDelta;
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof ChatCompletions200Response1ChoicesInner
     */
    'finish_reason': ChatCompletions200Response1ChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof ChatCompletions200Response1ChoicesInner
     */
    'index': number;
}

export const ChatCompletions200Response1ChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ToolCalls: 'tool_calls',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
} as const;

export type ChatCompletions200Response1ChoicesInnerFinishReasonEnum = typeof ChatCompletions200Response1ChoicesInnerFinishReasonEnum[keyof typeof ChatCompletions200Response1ChoicesInnerFinishReasonEnum];

/**
 * A chat completion delta generated by streamed model responses.
 * @export
 * @interface ChatCompletions200Response1ChoicesInnerDelta
 */
export interface ChatCompletions200Response1ChoicesInnerDelta {
    /**
     * The contents of the chunk message.
     * @type {string}
     * @memberof ChatCompletions200Response1ChoicesInnerDelta
     */
    'content'?: string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletions200Response1ChoicesInnerDelta
     */
    'role'?: ChatCompletions200Response1ChoicesInnerDeltaRoleEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletions200Response1ChoicesInnerDelta
     */
    'refusal'?: string;
    /**
     * 
     * @type {ChatCompletions200ResponseChoicesInnerMessageGabber}
     * @memberof ChatCompletions200Response1ChoicesInnerDelta
     */
    'gabber'?: ChatCompletions200ResponseChoicesInnerMessageGabber;
}

export const ChatCompletions200Response1ChoicesInnerDeltaRoleEnum = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant'
} as const;

export type ChatCompletions200Response1ChoicesInnerDeltaRoleEnum = typeof ChatCompletions200Response1ChoicesInnerDeltaRoleEnum[keyof typeof ChatCompletions200Response1ChoicesInnerDeltaRoleEnum];

/**
 * Gabber-specific fields
 * @export
 * @interface ChatCompletions200Response1Gabber
 */
export interface ChatCompletions200Response1Gabber {
    /**
     * 
     * @type {ChatCompletions200Response1GabberUsage}
     * @memberof ChatCompletions200Response1Gabber
     */
    'usage'?: ChatCompletions200Response1GabberUsage;
    /**
     * 
     * @type {Array<ChatCompletions200Response1GabberMessageDataInner>}
     * @memberof ChatCompletions200Response1Gabber
     */
    'message_data'?: Array<ChatCompletions200Response1GabberMessageDataInner>;
}
/**
 * 
 * @export
 * @interface ChatCompletions200Response1GabberMessageDataInner
 */
export interface ChatCompletions200Response1GabberMessageDataInner {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletions200Response1GabberMessageDataInner
     */
    'message_index': number;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletions200Response1GabberMessageDataInner
     */
    'content_index': number;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletions200Response1GabberMessageDataInner
     */
    'type': ChatCompletions200Response1GabberMessageDataInnerTypeEnum;
    /**
     * 
     * @type {ChatCompletions200Response1GabberMessageDataInnerData}
     * @memberof ChatCompletions200Response1GabberMessageDataInner
     */
    'data': ChatCompletions200Response1GabberMessageDataInnerData;
}

export const ChatCompletions200Response1GabberMessageDataInnerTypeEnum = {
    AudioTranscript: 'audio_transcript'
} as const;

export type ChatCompletions200Response1GabberMessageDataInnerTypeEnum = typeof ChatCompletions200Response1GabberMessageDataInnerTypeEnum[keyof typeof ChatCompletions200Response1GabberMessageDataInnerTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletions200Response1GabberMessageDataInnerData
 */
export interface ChatCompletions200Response1GabberMessageDataInnerData {
    /**
     * 
     * @type {string}
     * @memberof ChatCompletions200Response1GabberMessageDataInnerData
     */
    'transcript': string;
}
/**
 * Gabber usage for this request
 * @export
 * @interface ChatCompletions200Response1GabberUsage
 */
export interface ChatCompletions200Response1GabberUsage {
    /**
     * 
     * @type {string}
     * @memberof ChatCompletions200Response1GabberUsage
     */
    'type': ChatCompletions200Response1GabberUsageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletions200Response1GabberUsage
     */
    'value': number;
}

export const ChatCompletions200Response1GabberUsageTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type ChatCompletions200Response1GabberUsageTypeEnum = typeof ChatCompletions200Response1GabberUsageTypeEnum[keyof typeof ChatCompletions200Response1GabberUsageTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletions200ResponseChoicesInner
 */
export interface ChatCompletions200ResponseChoicesInner {
    /**
     * 
     * @type {ChatCompletions200ResponseChoicesInnerMessage}
     * @memberof ChatCompletions200ResponseChoicesInner
     */
    'message': ChatCompletions200ResponseChoicesInnerMessage;
}
/**
 * A chat completion message generated by the model.
 * @export
 * @interface ChatCompletions200ResponseChoicesInnerMessage
 */
export interface ChatCompletions200ResponseChoicesInnerMessage {
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletions200ResponseChoicesInnerMessage
     */
    'content': string;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletions200ResponseChoicesInnerMessage
     */
    'refusal': string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletions200ResponseChoicesInnerMessage
     */
    'role': ChatCompletions200ResponseChoicesInnerMessageRoleEnum;
    /**
     * 
     * @type {ChatCompletions200ResponseChoicesInnerMessageGabber}
     * @memberof ChatCompletions200ResponseChoicesInnerMessage
     */
    'gabber'?: ChatCompletions200ResponseChoicesInnerMessageGabber;
}

export const ChatCompletions200ResponseChoicesInnerMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ChatCompletions200ResponseChoicesInnerMessageRoleEnum = typeof ChatCompletions200ResponseChoicesInnerMessageRoleEnum[keyof typeof ChatCompletions200ResponseChoicesInnerMessageRoleEnum];

/**
 * If the audio output modality is requested, this object contains data
 * @export
 * @interface ChatCompletions200ResponseChoicesInnerMessageGabber
 */
export interface ChatCompletions200ResponseChoicesInnerMessageGabber {
    /**
     * 
     * @type {ChatCompletions200ResponseChoicesInnerMessageGabberVoice}
     * @memberof ChatCompletions200ResponseChoicesInnerMessageGabber
     */
    'voice'?: ChatCompletions200ResponseChoicesInnerMessageGabberVoice;
}
/**
 * 
 * @export
 * @interface ChatCompletions200ResponseChoicesInnerMessageGabberVoice
 */
export interface ChatCompletions200ResponseChoicesInnerMessageGabberVoice {
    /**
     * This will be the URL to the audio file
     * @type {string}
     * @memberof ChatCompletions200ResponseChoicesInnerMessageGabberVoice
     */
    'audio_url': string;
    /**
     * The Unix timestamp (in seconds) when the audio file expires
     * @type {number}
     * @memberof ChatCompletions200ResponseChoicesInnerMessageGabberVoice
     */
    'expires_at': number;
}
/**
 * 
 * @export
 * @interface ChatCompletions200ResponseGabber
 */
export interface ChatCompletions200ResponseGabber {
    /**
     * 
     * @type {Array<ChatCompletions200ResponseGabberMessageDataInner>}
     * @memberof ChatCompletions200ResponseGabber
     */
    'message_data'?: Array<ChatCompletions200ResponseGabberMessageDataInner>;
}
/**
 * 
 * @export
 * @interface ChatCompletions200ResponseGabberMessageDataInner
 */
export interface ChatCompletions200ResponseGabberMessageDataInner {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletions200ResponseGabberMessageDataInner
     */
    'message_index': number;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletions200ResponseGabberMessageDataInner
     */
    'content_index': number;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletions200ResponseGabberMessageDataInner
     */
    'type': ChatCompletions200ResponseGabberMessageDataInnerTypeEnum;
    /**
     * 
     * @type {ChatCompletions200ResponseGabberMessageDataInnerData}
     * @memberof ChatCompletions200ResponseGabberMessageDataInner
     */
    'data': ChatCompletions200ResponseGabberMessageDataInnerData;
}

export const ChatCompletions200ResponseGabberMessageDataInnerTypeEnum = {
    AudioTranscript: 'audio_transcript'
} as const;

export type ChatCompletions200ResponseGabberMessageDataInnerTypeEnum = typeof ChatCompletions200ResponseGabberMessageDataInnerTypeEnum[keyof typeof ChatCompletions200ResponseGabberMessageDataInnerTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletions200ResponseGabberMessageDataInnerData
 */
export interface ChatCompletions200ResponseGabberMessageDataInnerData {
    /**
     * 
     * @type {string}
     * @memberof ChatCompletions200ResponseGabberMessageDataInnerData
     */
    'transcript'?: string;
}
/**
 * 
 * @export
 * @interface ChatCompletionsRequest
 */
export interface ChatCompletionsRequest {
    /**
     * Chat context
     * @type {Array<ChatCompletionsRequestMessagesInner>}
     * @memberof ChatCompletionsRequest
     */
    'messages': Array<ChatCompletionsRequestMessagesInner>;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionsRequest
     */
    'model': string;
    /**
     * 
     * @type {object}
     * @memberof ChatCompletionsRequest
     */
    'metadata'?: object;
    /**
     * 
     * @type {ChatCompletionsRequestGabber}
     * @memberof ChatCompletionsRequest
     */
    'gabber'?: ChatCompletionsRequestGabber;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. 
     * @type {boolean}
     * @memberof ChatCompletionsRequest
     */
    'stream'?: boolean;
    /**
     * Temperature for sampling from the model. Higher values mean more randomness. 
     * @type {number}
     * @memberof ChatCompletionsRequest
     */
    'temperature'?: number;
    /**
     * Maximum number of tokens to generate. Requests can be up to 4096 tokens. 
     * @type {number}
     * @memberof ChatCompletionsRequest
     */
    'max_tokens'?: number;
}
/**
 * 
 * @export
 * @interface ChatCompletionsRequestGabber
 */
export interface ChatCompletionsRequestGabber {
    /**
     * Gabber voice id
     * @type {string}
     * @memberof ChatCompletionsRequestGabber
     */
    'voice'?: string;
}
/**
 * @type ChatCompletionsRequestMessagesInner
 * @export
 */
export type ChatCompletionsRequestMessagesInner = AssistantMessage | SystemMessage | UserMessage;

/**
 * 
 * @export
 * @interface CloneVoice200Response
 */
export interface CloneVoice200Response {
    /**
     * 
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'message': string;
    /**
     * Name of the cloned voice
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'name': string;
    /**
     * Language of the cloned voice
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'language': string;
    /**
     * Unique identifier of the cloned voice
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'human'?: string;
}
/**
 * 
 * @export
 * @interface ContextCreateRequest
 */
export interface ContextCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequest
     */
    'persona'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequest
     */
    'scenario'?: string;
    /**
     * 
     * @type {Array<ContextCreateRequestMessagesInner>}
     * @memberof ContextCreateRequest
     */
    'messages'?: Array<ContextCreateRequestMessagesInner>;
}
/**
 * 
 * @export
 * @interface ContextCreateRequestMessagesInner
 */
export interface ContextCreateRequestMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequestMessagesInner
     */
    'role': ContextCreateRequestMessagesInnerRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequestMessagesInner
     */
    'content': string;
}

export const ContextCreateRequestMessagesInnerRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextCreateRequestMessagesInnerRoleEnum = typeof ContextCreateRequestMessagesInnerRoleEnum[keyof typeof ContextCreateRequestMessagesInnerRoleEnum];

/**
 * 
 * @export
 * @interface ContextMessage
 */
export interface ContextMessage {
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'speaking_ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'role': ContextMessageRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'created_at': string;
}

export const ContextMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextMessageRoleEnum = typeof ContextMessageRoleEnum[keyof typeof ContextMessageRoleEnum];

/**
 * 
 * @export
 * @interface ContextMessageCreateParams
 */
export interface ContextMessageCreateParams {
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'speaking_ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'role': ContextMessageCreateParamsRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'content': string;
}

export const ContextMessageCreateParamsRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextMessageCreateParamsRoleEnum = typeof ContextMessageCreateParamsRoleEnum[keyof typeof ContextMessageCreateParamsRoleEnum];

/**
 * 
 * @export
 * @interface CreateCreditLedgerEntryRequest
 */
export interface CreateCreditLedgerEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * The name of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof CreateCreditRequest
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreatePersonaRequest
 */
export interface CreatePersonaRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'gender'?: CreatePersonaRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'voice': string;
}

export const CreatePersonaRequestGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type CreatePersonaRequestGenderEnum = typeof CreatePersonaRequestGenderEnum[keyof typeof CreatePersonaRequestGenderEnum];

/**
 * 
 * @export
 * @interface CreateScenarioRequest
 */
export interface CreateScenarioRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface CreateUsageToken200Response
 */
export interface CreateUsageToken200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateUsageToken200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * The date and time the credit was created.
     * @type {string}
     * @memberof Credit
     */
    'created_at': string;
    /**
     * The unique identifier of the credit.
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * The project the credit belongs to.
     * @type {string}
     * @memberof Credit
     */
    'project': string;
    /**
     * The name of the credit.
     * @type {string}
     * @memberof Credit
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof Credit
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof Credit
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreditLedgerEntry
 */
export interface CreditLedgerEntry {
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'credit': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'human': string;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface DeletePersona200Response
 */
export interface DeletePersona200Response {
    /**
     * 
     * @type {string}
     * @memberof DeletePersona200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteScenario200Response
 */
export interface DeleteScenario200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteScenario200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteVoice200Response
 */
export interface DeleteVoice200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteVoice200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GenerateVoiceRequest
 */
export interface GenerateVoiceRequest {
    /**
     * Text to synthesize into voice
     * @type {string}
     * @memberof GenerateVoiceRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateVoiceRequest
     */
    'voice_id': string;
    /**
     * Whether to moderate the text.
     * @type {boolean}
     * @memberof GenerateVoiceRequest
     */
    'moderation'?: boolean;
}
/**
 * 
 * @export
 * @interface HistoryMessage
 */
export interface HistoryMessage {
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'role': HistoryMessageRoleEnum;
}

export const HistoryMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type HistoryMessageRoleEnum = typeof HistoryMessageRoleEnum[keyof typeof HistoryMessageRoleEnum];

/**
 * @type InlineObject
 * @export
 */
export type InlineObject = InlineObjectOneOf | InlineObjectOneOf1 | InlineObjectOneOf2;

/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Error message.
     * @type {string}
     * @memberof InlineObject1
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface InlineObjectOneOf
 */
export interface InlineObjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf
     */
    'type'?: InlineObjectOneOfTypeEnum;
}

export const InlineObjectOneOfTypeEnum = {
    UsageLimitExceeded: 'usage_limit_exceeded'
} as const;

export type InlineObjectOneOfTypeEnum = typeof InlineObjectOneOfTypeEnum[keyof typeof InlineObjectOneOfTypeEnum];

/**
 * 
 * @export
 * @interface InlineObjectOneOf1
 */
export interface InlineObjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf1
     */
    'type'?: InlineObjectOneOf1TypeEnum;
}

export const InlineObjectOneOf1TypeEnum = {
    ProjectDisabled: 'project_disabled'
} as const;

export type InlineObjectOneOf1TypeEnum = typeof InlineObjectOneOf1TypeEnum[keyof typeof InlineObjectOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface InlineObjectOneOf2
 */
export interface InlineObjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf2
     */
    'type'?: InlineObjectOneOf2TypeEnum;
}

export const InlineObjectOneOf2TypeEnum = {
    ModerationError: 'moderation_error'
} as const;

export type InlineObjectOneOf2TypeEnum = typeof InlineObjectOneOf2TypeEnum[keyof typeof InlineObjectOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface LLM
 */
export interface LLM {
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof LLM
     */
    'compliance': boolean;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ListContextMessages200Response
 */
export interface ListContextMessages200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof ListContextMessages200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof ListContextMessages200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<ContextMessage>}
     * @memberof ListContextMessages200Response
     */
    'values': Array<ContextMessage>;
}
/**
 * 
 * @export
 * @interface ListCredits200Response
 */
export interface ListCredits200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListCredits200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListCredits200Response
     */
    'total_count': number;
    /**
     * The array of credits.
     * @type {Array<Credit>}
     * @memberof ListCredits200Response
     */
    'values': Array<Credit>;
}
/**
 * 
 * @export
 * @interface ListLLMs200Response
 */
export interface ListLLMs200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListLLMs200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListLLMs200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<LLM>}
     * @memberof ListLLMs200Response
     */
    'values': Array<LLM>;
}
/**
 * 
 * @export
 * @interface ListPersonas200Response
 */
export interface ListPersonas200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListPersonas200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListPersonas200Response
     */
    'total_count': number;
    /**
     * The array of personas.
     * @type {Array<Persona>}
     * @memberof ListPersonas200Response
     */
    'values': Array<Persona>;
}
/**
 * 
 * @export
 * @interface ListRealtimeSessions200Response
 */
export interface ListRealtimeSessions200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof ListRealtimeSessions200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof ListRealtimeSessions200Response
     */
    'total_count'?: number;
    /**
     * The list of items.
     * @type {Array<RealtimeSession>}
     * @memberof ListRealtimeSessions200Response
     */
    'values'?: Array<RealtimeSession>;
}
/**
 * 
 * @export
 * @interface ListScenarios200Response
 */
export interface ListScenarios200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListScenarios200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListScenarios200Response
     */
    'total_count': number;
    /**
     * The array of scenarios.
     * @type {Array<Scenario>}
     * @memberof ListScenarios200Response
     */
    'values': Array<Scenario>;
}
/**
 * 
 * @export
 * @interface ListVoices200Response
 */
export interface ListVoices200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListVoices200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListVoices200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<Voice>}
     * @memberof ListVoices200Response
     */
    'values': Array<Voice>;
}
/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>}
     * @memberof Persona
     */
    'tags'?: Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'voice': string;
}

export const PersonaGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type PersonaGenderEnum = typeof PersonaGenderEnum[keyof typeof PersonaGenderEnum];

/**
 * 
 * @export
 * @interface RealtimeSession
 */
export interface RealtimeSession {
    /**
     * The unique identifier of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSession
     */
    'id': string;
    /**
     * The current state of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSession
     */
    'state': RealtimeSessionStateEnum;
    /**
     * The time the RealtimeSession was created.
     * @type {string}
     * @memberof RealtimeSession
     */
    'created_at': string;
    /**
     * The time the RealtimeSession ended.
     * @type {string}
     * @memberof RealtimeSession
     */
    'ended_at'?: string;
    /**
     * The project identifier.
     * @type {string}
     * @memberof RealtimeSession
     */
    'project': string;
    /**
     * The human identifier.
     * @type {string}
     * @memberof RealtimeSession
     */
    'human'?: string;
    /**
     * Whether the session is simulated or not.
     * @type {boolean}
     * @memberof RealtimeSession
     */
    'simulated': boolean;
    /**
     * 
     * @type {RealtimeSessionConfig}
     * @memberof RealtimeSession
     */
    'config': RealtimeSessionConfig;
}

export const RealtimeSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type RealtimeSessionStateEnum = typeof RealtimeSessionStateEnum[keyof typeof RealtimeSessionStateEnum];

/**
 * 
 * @export
 * @interface RealtimeSessionConfig
 */
export interface RealtimeSessionConfig {
    /**
     * 
     * @type {RealtimeSessionConfigGeneral}
     * @memberof RealtimeSessionConfig
     */
    'general': RealtimeSessionConfigGeneral;
    /**
     * 
     * @type {RealtimeSessionConfigInput}
     * @memberof RealtimeSessionConfig
     */
    'input': RealtimeSessionConfigInput;
    /**
     * 
     * @type {RealtimeSessionConfigGenerative}
     * @memberof RealtimeSessionConfig
     */
    'generative': RealtimeSessionConfigGenerative;
    /**
     * 
     * @type {RealtimeSessionConfigOutput}
     * @memberof RealtimeSessionConfig
     */
    'output': RealtimeSessionConfigOutput;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigGeneral
 */
export interface RealtimeSessionConfigGeneral {
    /**
     * The time limit in seconds for the RealtimeSession.
     * @type {number}
     * @memberof RealtimeSessionConfigGeneral
     */
    'time_limit_s'?: number;
    /**
     * Whether to save messages in the RealtimeSession. These will be saved to the context provided in the generative config. If no context is provided, a new context will be created when the session starts. 
     * @type {boolean}
     * @memberof RealtimeSessionConfigGeneral
     */
    'save_messages': boolean;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigGenerative
 */
export interface RealtimeSessionConfigGenerative {
    /**
     * Identifier for the LLM to use in the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionConfigGenerative
     */
    'llm': string;
    /**
     * Identifier for the voice to use in speech synthesis. If a persona is set, this will override the persona\'s voice.
     * @type {string}
     * @memberof RealtimeSessionConfigGenerative
     */
    'voice_override'?: string;
    /**
     * Persona identifier. Personas become part of the prompt and voice.
     * @type {string}
     * @memberof RealtimeSessionConfigGenerative
     */
    'persona'?: string;
    /**
     * Scenario identifier to set the context of the session.
     * @type {string}
     * @memberof RealtimeSessionConfigGenerative
     */
    'scenario'?: string;
    /**
     * Which context to provide to the AI. Messages will be saved here if save_messages is true in the general config. 
     * @type {string}
     * @memberof RealtimeSessionConfigGenerative
     */
    'context': string;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof RealtimeSessionConfigGenerative
     */
    '_extra'?: { [key: string]: any; };
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionConfigInput
 */
export interface RealtimeSessionConfigInput {
    /**
     * Whether the system allows interruption during speech.
     * @type {boolean}
     * @memberof RealtimeSessionConfigInput
     */
    'interruptable': boolean;
    /**
     * Whether the AI should continue listening while speaking. If true, the AI will produce another response immediately after the first one. This is only relevant if interruptable is false. 
     * @type {boolean}
     * @memberof RealtimeSessionConfigInput
     */
    'parallel_listening': boolean;
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionConfigOutput
 */
export interface RealtimeSessionConfigOutput {
    /**
     * Whether the AI should stream the output text.
     * @type {boolean}
     * @memberof RealtimeSessionConfigOutput
     */
    'stream_transcript': boolean;
    /**
     * Whether the AI should synthesize speech.
     * @type {boolean}
     * @memberof RealtimeSessionConfigOutput
     */
    'speech_synthesis_enabled': boolean;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigPartial
 */
export interface RealtimeSessionConfigPartial {
    /**
     * 
     * @type {RealtimeSessionConfigPartialGeneral}
     * @memberof RealtimeSessionConfigPartial
     */
    'general'?: RealtimeSessionConfigPartialGeneral;
    /**
     * 
     * @type {RealtimeSessionConfigPartialInput}
     * @memberof RealtimeSessionConfigPartial
     */
    'input'?: RealtimeSessionConfigPartialInput;
    /**
     * 
     * @type {RealtimeSessionConfigPartialGenerative}
     * @memberof RealtimeSessionConfigPartial
     */
    'generative'?: RealtimeSessionConfigPartialGenerative;
    /**
     * 
     * @type {RealtimeSessionConfigPartialOutput}
     * @memberof RealtimeSessionConfigPartial
     */
    'output'?: RealtimeSessionConfigPartialOutput;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigPartialGeneral
 */
export interface RealtimeSessionConfigPartialGeneral {
    /**
     * The time limit in seconds for the RealtimeSession.
     * @type {number}
     * @memberof RealtimeSessionConfigPartialGeneral
     */
    'time_limit_s'?: number;
    /**
     * Whether to save messages in the RealtimeSession. These will be saved to the context provided in the generative config. If no context is provided, a new context will be created when the session starts. 
     * @type {boolean}
     * @memberof RealtimeSessionConfigPartialGeneral
     */
    'save_messages'?: boolean;
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionConfigPartialGenerative
 */
export interface RealtimeSessionConfigPartialGenerative {
    /**
     * Identifier for the LLM to use in the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionConfigPartialGenerative
     */
    'llm'?: string;
    /**
     * Identifier for the voice to use in speech synthesis. If a persona is set, this will override the persona\'s voice.
     * @type {string}
     * @memberof RealtimeSessionConfigPartialGenerative
     */
    'voice_override'?: string;
    /**
     * Persona identifier. Personas become part of the prompt and voice.
     * @type {string}
     * @memberof RealtimeSessionConfigPartialGenerative
     */
    'persona'?: string;
    /**
     * Scenario identifier to set the context of the session.
     * @type {string}
     * @memberof RealtimeSessionConfigPartialGenerative
     */
    'scenario'?: string;
    /**
     * Which context to provide to the AI. Messages will be saved here if save_messages is true in the general config. 
     * @type {string}
     * @memberof RealtimeSessionConfigPartialGenerative
     */
    'context'?: string;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof RealtimeSessionConfigPartialGenerative
     */
    '_extra'?: { [key: string]: any; };
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionConfigPartialInput
 */
export interface RealtimeSessionConfigPartialInput {
    /**
     * Whether the system allows interruption during speech.
     * @type {boolean}
     * @memberof RealtimeSessionConfigPartialInput
     */
    'interruptable'?: boolean;
    /**
     * Whether the AI should continue listening while speaking. If true, the AI will produce another response immediately after the first one. This is only relevant if interruptable is false. 
     * @type {boolean}
     * @memberof RealtimeSessionConfigPartialInput
     */
    'parallel_listening'?: boolean;
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionConfigPartialOutput
 */
export interface RealtimeSessionConfigPartialOutput {
    /**
     * Whether the AI should stream the output text.
     * @type {boolean}
     * @memberof RealtimeSessionConfigPartialOutput
     */
    'stream_transcript'?: boolean;
    /**
     * Whether the AI should synthesize speech.
     * @type {boolean}
     * @memberof RealtimeSessionConfigPartialOutput
     */
    'speech_synthesis_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface RealtimeSessionStartResponse
 */
export interface RealtimeSessionStartResponse {
    /**
     * 
     * @type {RealtimeSessionStartResponseSession}
     * @memberof RealtimeSessionStartResponse
     */
    'session': RealtimeSessionStartResponseSession;
    /**
     * 
     * @type {RealtimeSessionStartResponseConnectionDetails}
     * @memberof RealtimeSessionStartResponse
     */
    'connection_details': RealtimeSessionStartResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface RealtimeSessionStartResponseConnectionDetails
 */
export interface RealtimeSessionStartResponseConnectionDetails {
    /**
     * The URL to connect to the RealtimeSession
     * @type {string}
     * @memberof RealtimeSessionStartResponseConnectionDetails
     */
    'url': string;
    /**
     * The token to use to connect to the RealtimeSession
     * @type {string}
     * @memberof RealtimeSessionStartResponseConnectionDetails
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RealtimeSessionStartResponseSession
 */
export interface RealtimeSessionStartResponseSession {
    /**
     * The unique identifier of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionStartResponseSession
     */
    'id': string;
    /**
     * The current state of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionStartResponseSession
     */
    'state': RealtimeSessionStartResponseSessionStateEnum;
    /**
     * The time the RealtimeSession was created.
     * @type {string}
     * @memberof RealtimeSessionStartResponseSession
     */
    'created_at': string;
    /**
     * The time the RealtimeSession ended.
     * @type {string}
     * @memberof RealtimeSessionStartResponseSession
     */
    'ended_at'?: string;
    /**
     * The project identifier.
     * @type {string}
     * @memberof RealtimeSessionStartResponseSession
     */
    'project': string;
    /**
     * The human identifier.
     * @type {string}
     * @memberof RealtimeSessionStartResponseSession
     */
    'human'?: string;
    /**
     * Whether the session is simulated or not.
     * @type {boolean}
     * @memberof RealtimeSessionStartResponseSession
     */
    'simulated': boolean;
    /**
     * 
     * @type {RealtimeSessionConfig}
     * @memberof RealtimeSessionStartResponseSession
     */
    'config': RealtimeSessionConfig;
}

export const RealtimeSessionStartResponseSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type RealtimeSessionStartResponseSessionStateEnum = typeof RealtimeSessionStartResponseSessionStateEnum[keyof typeof RealtimeSessionStartResponseSessionStateEnum];

/**
 * 
 * @export
 * @interface RefusalContentPart
 */
export interface RefusalContentPart {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof RefusalContentPart
     */
    'type': RefusalContentPartTypeEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof RefusalContentPart
     */
    'refusal': string;
}

export const RefusalContentPartTypeEnum = {
    Refusal: 'refusal'
} as const;

export type RefusalContentPartTypeEnum = typeof RefusalContentPartTypeEnum[keyof typeof RefusalContentPartTypeEnum];

/**
 * 
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof Session
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'state': SessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'time_limit_s': number;
}

export const SessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type SessionStateEnum = typeof SessionStateEnum[keyof typeof SessionStateEnum];

/**
 * 
 * @export
 * @interface SessionMessage
 */
export interface SessionMessage {
    /**
     * 
     * @type {boolean}
     * @memberof SessionMessage
     */
    'agent': boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'import_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'media'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'session': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'speaking_ended_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface SessionTimelineItem
 */
export interface SessionTimelineItem {
    /**
     * 
     * @type {number}
     * @memberof SessionTimelineItem
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionTimelineItem
     */
    'type'?: SessionTimelineItemTypeEnum;
}

export const SessionTimelineItemTypeEnum = {
    Silence: 'silence',
    Agent: 'agent',
    User: 'user'
} as const;

export type SessionTimelineItemTypeEnum = typeof SessionTimelineItemTypeEnum[keyof typeof SessionTimelineItemTypeEnum];

/**
 * 
 * @export
 * @interface StartRealtimeSessionRequest
 */
export interface StartRealtimeSessionRequest {
    /**
     * Whether the session is simulated.
     * @type {boolean}
     * @memberof StartRealtimeSessionRequest
     */
    'simulated'?: boolean;
    /**
     * 
     * @type {RealtimeSessionConfigPartial}
     * @memberof StartRealtimeSessionRequest
     */
    'config': RealtimeSessionConfigPartial;
}
/**
 * 
 * @export
 * @interface SystemMessage
 */
export interface SystemMessage {
    /**
     * 
     * @type {SystemMessageContent}
     * @memberof SystemMessage
     */
    'content': SystemMessageContent;
    /**
     * The role of the messages author, in this case `system`.
     * @type {string}
     * @memberof SystemMessage
     */
    'role': SystemMessageRoleEnum;
}

export const SystemMessageRoleEnum = {
    System: 'system'
} as const;

export type SystemMessageRoleEnum = typeof SystemMessageRoleEnum[keyof typeof SystemMessageRoleEnum];

/**
 * @type SystemMessageContent
 * The contents of the system message.
 * @export
 */
export type SystemMessageContent = Array<SystemMessageContentOneOfInner> | string;

/**
 * @type SystemMessageContentOneOfInner
 * @export
 */
export type SystemMessageContentOneOfInner = TextContentPart;

/**
 * Text content
 * @export
 * @interface TextContentPart
 */
export interface TextContentPart {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof TextContentPart
     */
    'type': TextContentPartTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof TextContentPart
     */
    'text': string;
}

export const TextContentPartTypeEnum = {
    Text: 'text'
} as const;

export type TextContentPartTypeEnum = typeof TextContentPartTypeEnum[keyof typeof TextContentPartTypeEnum];

/**
 * 
 * @export
 * @interface UpdatePersonaRequest
 */
export interface UpdatePersonaRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'gender'?: UpdatePersonaRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'voice'?: string;
}

export const UpdatePersonaRequestGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type UpdatePersonaRequestGenderEnum = typeof UpdatePersonaRequestGenderEnum[keyof typeof UpdatePersonaRequestGenderEnum];

/**
 * 
 * @export
 * @interface UpdateScenarioRequest
 */
export interface UpdateScenarioRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'prompt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUsageTokenRequest
 */
export interface UpdateUsageTokenRequest {
    /**
     * 
     * @type {Array<UpdateUsageTokenRequestLimitsInner>}
     * @memberof UpdateUsageTokenRequest
     */
    'limits': Array<UpdateUsageTokenRequestLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof UpdateUsageTokenRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @interface UpdateUsageTokenRequestLimitsInner
 */
export interface UpdateUsageTokenRequestLimitsInner {
    /**
     * 
     * @type {string}
     * @memberof UpdateUsageTokenRequestLimitsInner
     */
    'type': UpdateUsageTokenRequestLimitsInnerTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateUsageTokenRequestLimitsInner
     */
    'value': number;
}

export const UpdateUsageTokenRequestLimitsInnerTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type UpdateUsageTokenRequestLimitsInnerTypeEnum = typeof UpdateUsageTokenRequestLimitsInnerTypeEnum[keyof typeof UpdateUsageTokenRequestLimitsInnerTypeEnum];

/**
 * 
 * @export
 * @interface UpdateVoiceRequest
 */
export interface UpdateVoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateVoiceRequest
     */
    'name': string;
    /**
     * The language of the voice
     * @type {string}
     * @memberof UpdateVoiceRequest
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    'type': UsageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    'value': number;
}

export const UsageTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type UsageTypeEnum = typeof UsageTypeEnum[keyof typeof UsageTypeEnum];

/**
 * 
 * @export
 * @interface UserMessage
 */
export interface UserMessage {
    /**
     * 
     * @type {UserMessageContent}
     * @memberof UserMessage
     */
    'content': UserMessageContent;
    /**
     * The role of the messages author, in this case `user`.
     * @type {string}
     * @memberof UserMessage
     */
    'role': UserMessageRoleEnum;
}

export const UserMessageRoleEnum = {
    User: 'user'
} as const;

export type UserMessageRoleEnum = typeof UserMessageRoleEnum[keyof typeof UserMessageRoleEnum];

/**
 * @type UserMessageContent
 * The contents of the user message.
 * @export
 */
export type UserMessageContent = Array<UserMessageContentOneOfInner> | string;

/**
 * @type UserMessageContentOneOfInner
 * @export
 */
export type UserMessageContentOneOfInner = AudioContentPart | TextContentPart;

/**
 * 
 * @export
 * @interface Voice
 */
export interface Voice {
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'voice'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Voice
     */
    'embeddings'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'cartesia_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'elevenlabs_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'human_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'preview_url'?: string;
    /**
     * Extra configuration for the voice. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof Voice
     */
    '_extra'?: { [key: string]: any; };
}

/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit: async (createCreditRequest: CreateCreditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCreditRequest' is not null or undefined
            assertParamExists('createCredit', 'createCreditRequest', createCreditRequest)
            const localVarPath = `/api/v1/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCreditLedgerEntry: async (credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('createCreditLedgerEntry', 'credit', credit)
            // verify required parameter 'createCreditLedgerEntryRequest' is not null or undefined
            assertParamExists('createCreditLedgerEntry', 'createCreditLedgerEntryRequest', createCreditLedgerEntryRequest)
            const localVarPath = `/api/v1/credit/{credit}/ledger`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditLedgerEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit: async (credit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('getCredit', 'credit', credit)
            const localVarPath = `/api/v1/credit/{credit}`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCreditLedgerEntry: async (credit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('getLatestCreditLedgerEntry', 'credit', credit)
            const localVarPath = `/api/v1/credit/{credit}/ledger/latest`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/credit/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredit(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredit(credit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredit(credit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestCreditLedgerEntry(credit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestCreditLedgerEntry(credit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getLatestCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCredits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.listCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditApiFp(configuration)
    return {
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.createCredit(createCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(credit: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.getCredit(credit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCreditLedgerEntry(credit: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.getLatestCreditLedgerEntry(credit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(options?: RawAxiosRequestConfig): AxiosPromise<ListCredits200Response> {
            return localVarFp.listCredits(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * Creates a new credit based on the input request data
     * @summary Create a new credit
     * @param {CreateCreditRequest} createCreditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCredit(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCredit(createCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new credit ledger entry for human. Requires a human id.
     * @summary Create a new credit ledger entry
     * @param {string} credit 
     * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single credit object
     * @param {string} credit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getCredit(credit: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getCredit(credit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest credit ledger entry for a human. Requires a human id.
     * @param {string} credit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getLatestCreditLedgerEntry(credit: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getLatestCreditLedgerEntry(credit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public listCredits(options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).listCredits(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InferenceApi - axios parameter creator
 * @export
 */
export const InferenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionsRequest} chatCompletionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCompletions: async (chatCompletionsRequest: ChatCompletionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatCompletionsRequest' is not null or undefined
            assertParamExists('chatCompletions', 'chatCompletionsRequest', chatCompletionsRequest)
            const localVarPath = `/api/v1/chat/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatCompletionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InferenceApi - functional programming interface
 * @export
 */
export const InferenceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InferenceApiAxiosParamCreator(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionsRequest} chatCompletionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatCompletions(chatCompletionsRequest: ChatCompletionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatCompletions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatCompletions(chatCompletionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InferenceApi.chatCompletions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InferenceApi - factory interface
 * @export
 */
export const InferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InferenceApiFp(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionsRequest} chatCompletionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCompletions(chatCompletionsRequest: ChatCompletionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatCompletions200Response> {
            return localVarFp.chatCompletions(chatCompletionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InferenceApi - object-oriented interface
 * @export
 * @class InferenceApi
 * @extends {BaseAPI}
 */
export class InferenceApi extends BaseAPI {
    /**
     * Given messages, generates LLM output text and optionally speech
     * @summary Chat Completions (+ Voice)
     * @param {ChatCompletionsRequest} chatCompletionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InferenceApi
     */
    public chatCompletions(chatCompletionsRequest: ChatCompletionsRequest, options?: RawAxiosRequestConfig) {
        return InferenceApiFp(this.configuration).chatCompletions(chatCompletionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMApi - axios parameter creator
 * @export
 */
export const LLMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext: async (contextCreateRequest: ContextCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextCreateRequest' is not null or undefined
            assertParamExists('createContext', 'contextCreateRequest', contextCreateRequest)
            const localVarPath = `/api/v1/llm/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContextMessage: async (context: string, contextMessageCreateParams: ContextMessageCreateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('createContextMessage', 'context', context)
            // verify required parameter 'contextMessageCreateParams' is not null or undefined
            assertParamExists('createContextMessage', 'contextMessageCreateParams', contextMessageCreateParams)
            const localVarPath = `/api/v1/llm/context/{context}/message`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextMessageCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getContext', 'context', context)
            const localVarPath = `/api/v1/llm/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextMessage: async (context: string, message: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getContextMessage', 'context', context)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('getContextMessage', 'message', message)
            const localVarPath = `/api/v1/llm/context/{context}/message/{message}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLLM: async (llm: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'llm' is not null or undefined
            assertParamExists('getLLM', 'llm', llm)
            const localVarPath = `/api/v1/llm/{llm}`
                .replace(`{${"llm"}}`, encodeURIComponent(String(llm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContextMessages: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('listContextMessages', 'context', context)
            const localVarPath = `/api/v1/llm/context/{context}/message/list`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLLMs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/llm/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMApi - functional programming interface
 * @export
 */
export const LLMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContext(contextCreateRequest: ContextCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(contextCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContextMessage(context, contextMessageCreateParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContextMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContext(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextMessage(context: string, message: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextMessage(context, message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContextMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLLM(llm: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LLM>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLLM(llm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getLLM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContextMessages(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContextMessages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContextMessages(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.listContextMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLLMs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLLMs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLLMs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.listLLMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMApi - factory interface
 * @export
 */
export const LLMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMApiFp(configuration)
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext(contextCreateRequest: ContextCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Context> {
            return localVarFp.createContext(contextCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {
            return localVarFp.createContextMessage(context, contextMessageCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(context: string, options?: RawAxiosRequestConfig): AxiosPromise<Context> {
            return localVarFp.getContext(context, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextMessage(context: string, message: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {
            return localVarFp.getContextMessage(context, message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLLM(llm: string, options?: RawAxiosRequestConfig): AxiosPromise<LLM> {
            return localVarFp.getLLM(llm, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContextMessages(context: string, options?: RawAxiosRequestConfig): AxiosPromise<ListContextMessages200Response> {
            return localVarFp.listContextMessages(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLLMs(options?: RawAxiosRequestConfig): AxiosPromise<ListLLMs200Response> {
            return localVarFp.listLLMs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMApi - object-oriented interface
 * @export
 * @class LLMApi
 * @extends {BaseAPI}
 */
export class LLMApi extends BaseAPI {
    /**
     * Create a new Context with the given configuration. 
     * @summary Create a new Context.
     * @param {ContextCreateRequest} contextCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public createContext(contextCreateRequest: ContextCreateRequest, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).createContext(contextCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ContextMessage with the given configuration. 
     * @summary Create a new ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {ContextMessageCreateParams} contextMessageCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).createContextMessage(context, contextMessageCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Context with the given identifier. 
     * @summary Retrieve a Context.
     * @param {string} context The unique identifier of the Context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getContext(context: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getContext(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the ContextMessage with the given identifier. 
     * @summary Retrieve a ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {string} message The unique identifier of the ContextMessage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getContextMessage(context: string, message: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getContextMessage(context, message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of llms
     * @param {string} llm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getLLM(llm: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getLLM(llm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ContextMessages associated with the given Context. 
     * @summary List ContextMessages.
     * @param {string} context The unique identifier of the Context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public listContextMessages(context: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).listContextMessages(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of llms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public listLLMs(options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).listLLMs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona: async (createPersonaRequest: CreatePersonaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonaRequest' is not null or undefined
            assertParamExists('createPersona', 'createPersonaRequest', createPersonaRequest)
            const localVarPath = `/api/v1/persona`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona: async (personaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('deletePersona', 'personaId', personaId)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersona: async (personaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPersona', 'personaId', personaId)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/persona/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona: async (personaId: string, updatePersonaRequest: UpdatePersonaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('updatePersona', 'personaId', personaId)
            // verify required parameter 'updatePersonaRequest' is not null or undefined
            assertParamExists('updatePersona', 'updatePersonaRequest', updatePersonaRequest)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.createPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersona(personaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePersona200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.deletePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersona(personaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersona(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.getPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPersonas200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.listPersonas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(personaId, updatePersonaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.updatePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.createPersona(createPersonaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona(personaId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletePersona200Response> {
            return localVarFp.deletePersona(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersona(personaId: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getPersona(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas(options?: RawAxiosRequestConfig): AxiosPromise<ListPersonas200Response> {
            return localVarFp.listPersonas(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.updatePersona(personaId, updatePersonaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * 
     * @summary Get a persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).createPersona(createPersonaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public deletePersona(personaId: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).deletePersona(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public getPersona(personaId: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).getPersona(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of personas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public listPersonas(options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).listPersonas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a persona
     * @param {string} personaId 
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).updatePersona(personaId, updatePersonaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealtimeApi - axios parameter creator
 * @export
 */
export const RealtimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endRealtimeSession: async (session: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('endRealtimeSession', 'session', session)
            const localVarPath = `/api/v1/realtime/{session}/end`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSession: async (session: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('getRealtimeSession', 'session', session)
            const localVarPath = `/api/v1/realtime/{session}`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealtimeSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/realtime/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRealtimeSession: async (startRealtimeSessionRequest: StartRealtimeSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startRealtimeSessionRequest' is not null or undefined
            assertParamExists('startRealtimeSession', 'startRealtimeSessionRequest', startRealtimeSessionRequest)
            const localVarPath = `/api/v1/realtime/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRealtimeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigPartial} realtimeSessionConfigPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealtimeSession: async (session: string, realtimeSessionConfigPartial: RealtimeSessionConfigPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('updateRealtimeSession', 'session', session)
            // verify required parameter 'realtimeSessionConfigPartial' is not null or undefined
            assertParamExists('updateRealtimeSession', 'realtimeSessionConfigPartial', realtimeSessionConfigPartial)
            const localVarPath = `/api/v1/realtime/{session}/update`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionConfigPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealtimeApi - functional programming interface
 * @export
 */
export const RealtimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration)
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endRealtimeSession(session: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endRealtimeSession(session, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.endRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimeSession(session: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSession(session, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRealtimeSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRealtimeSessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRealtimeSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.listRealtimeSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSessionStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRealtimeSession(startRealtimeSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.startRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigPartial} realtimeSessionConfigPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRealtimeSession(session: string, realtimeSessionConfigPartial: RealtimeSessionConfigPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRealtimeSession(session, realtimeSessionConfigPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.updateRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealtimeApi - factory interface
 * @export
 */
export const RealtimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealtimeApiFp(configuration)
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endRealtimeSession(session: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.endRealtimeSession(session, options).then((request) => request(axios, basePath));
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSession(session: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.getRealtimeSession(session, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealtimeSessions(options?: RawAxiosRequestConfig): AxiosPromise<ListRealtimeSessions200Response> {
            return localVarFp.listRealtimeSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSessionStartResponse> {
            return localVarFp.startRealtimeSession(startRealtimeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigPartial} realtimeSessionConfigPartial 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealtimeSession(session: string, realtimeSessionConfigPartial: RealtimeSessionConfigPartial, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.updateRealtimeSession(session, realtimeSessionConfigPartial, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealtimeApi - object-oriented interface
 * @export
 * @class RealtimeApi
 * @extends {BaseAPI}
 */
export class RealtimeApi extends BaseAPI {
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public endRealtimeSession(session: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).endRealtimeSession(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public getRealtimeSession(session: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).getRealtimeSession(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Realtime Sessions. 
     * @summary List Realtime Sessions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public listRealtimeSessions(options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).listRealtimeSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new RealtimeSession with the given configuration. 
     * @summary Start a new RealtimeSession.
     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).startRealtimeSession(startRealtimeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the RealtimeSession with the given identifier. 
     * @summary Update a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {RealtimeSessionConfigPartial} realtimeSessionConfigPartial 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public updateRealtimeSession(session: string, realtimeSessionConfigPartial: RealtimeSessionConfigPartial, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).updateRealtimeSession(session, realtimeSessionConfigPartial, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioScenarioIdGet: async (scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('apiV1ScenarioScenarioIdGet', 'scenarioId', scenarioId)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario: async (createScenarioRequest: CreateScenarioRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('createScenario', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/api/v1/scenario`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario: async (scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenario', 'scenarioId', scenarioId)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenarios: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/scenario/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario: async (scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenario', 'scenarioId', scenarioId)
            // verify required parameter 'updateScenarioRequest' is not null or undefined
            assertParamExists('updateScenario', 'updateScenarioRequest', updateScenarioRequest)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScenarioScenarioIdGet(scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ScenarioScenarioIdGet(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.apiV1ScenarioScenarioIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.createScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenario(scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteScenario200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.deleteScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScenarios(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListScenarios200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScenarios(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.listScenarios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(scenarioId, updateScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.updateScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioScenarioIdGet(scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.apiV1ScenarioScenarioIdGet(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.createScenario(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario(scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteScenario200Response> {
            return localVarFp.deleteScenario(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenarios(options?: RawAxiosRequestConfig): AxiosPromise<ListScenarios200Response> {
            return localVarFp.listScenarios(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.updateScenario(scenarioId, updateScenarioRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public apiV1ScenarioScenarioIdGet(scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).apiV1ScenarioScenarioIdGet(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).createScenario(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteScenario(scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteScenario(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public listScenarios(options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).listScenarios(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scenario
     * @param {string} scenarioId 
     * @param {UpdateScenarioRequest} updateScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenario(scenarioId, updateScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionListGet: async (human?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/session/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (human !== undefined) {
                localVarQueryParameter['human'] = human;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdEndPost', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/end`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdMessagesGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/messages`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut: async (sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'sessionId', sessionId)
            // verify required parameter 'apiV1SessionSessionIdPutRequest' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'apiV1SessionSessionIdPutRequest', apiV1SessionSessionIdPutRequest)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1SessionSessionIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdTimelineGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/timeline`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost: async (apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1SessionStartPostRequest' is not null or undefined
            assertParamExists('apiV1SessionStartPost', 'apiV1SessionStartPostRequest', apiV1SessionStartPostRequest)
            const localVarPath = `/api/v1/session/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1SessionStartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionListGet(human, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdEndPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdTimelineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionStartPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(apiV1SessionStartPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionListGet200Response> {
            return localVarFp.apiV1SessionListGet(human, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.apiV1SessionSessionIdGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response> {
            return localVarFp.apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response> {
            return localVarFp.apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionStartPost200Response> {
            return localVarFp.apiV1SessionStartPost(apiV1SessionStartPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of sessions
     * @param {string} [human] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionListGet(human, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new session based on the input request data
     * @summary Create a new session
     * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionStartPost(apiV1SessionStartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageToken: async (updateUsageTokenRequest: UpdateUsageTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUsageTokenRequest' is not null or undefined
            assertParamExists('createUsageToken', 'updateUsageTokenRequest', updateUsageTokenRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/usage/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageToken: async (updateUsageTokenRequest: UpdateUsageTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUsageTokenRequest' is not null or undefined
            assertParamExists('updateUsageToken', 'updateUsageTokenRequest', updateUsageTokenRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageToken(updateUsageTokenRequest: UpdateUsageTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUsageToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageToken(updateUsageTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.createUsageToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateUsageTokenRequestLimitsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.getUsageLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageToken(updateUsageTokenRequest: UpdateUsageTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageToken(updateUsageTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.updateUsageToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageToken(updateUsageTokenRequest: UpdateUsageTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUsageToken200Response> {
            return localVarFp.createUsageToken(updateUsageTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageLimits(options?: RawAxiosRequestConfig): AxiosPromise<Array<UpdateUsageTokenRequestLimitsInner>> {
            return localVarFp.getUsageLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageToken(updateUsageTokenRequest: UpdateUsageTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateUsageToken(updateUsageTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public createUsageToken(updateUsageTokenRequest: UpdateUsageTokenRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).createUsageToken(updateUsageTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsageLimits(options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).getUsageLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the usage limits of a human
     * @summary Update human usage limits
     * @param {UpdateUsageTokenRequest} updateUsageTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public updateUsageToken(updateUsageTokenRequest: UpdateUsageTokenRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).updateUsageToken(updateUsageTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceApi - axios parameter creator
 * @export
 */
export const VoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneVoice: async (name: string, language: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('cloneVoice', 'name', name)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('cloneVoice', 'language', language)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('cloneVoice', 'file', file)
            const localVarPath = `/api/v1/voice/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('deleteVoice', 'voiceId', voiceId)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateVoice: async (generateVoiceRequest: GenerateVoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateVoiceRequest' is not null or undefined
            assertParamExists('generateVoice', 'generateVoiceRequest', generateVoiceRequest)
            const localVarPath = `/api/v1/voice/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateVoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('getVoice', 'voiceId', voiceId)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/voice/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoice: async (voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('updateVoice', 'voiceId', voiceId)
            // verify required parameter 'updateVoiceRequest' is not null or undefined
            assertParamExists('updateVoice', 'updateVoiceRequest', updateVoiceRequest)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceApi - functional programming interface
 * @export
 */
export const VoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneVoice(name: string, language: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloneVoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneVoice(name, language, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.cloneVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoice(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.deleteVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateVoice(generateVoiceRequest: GenerateVoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateVoice(generateVoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.generateVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoice(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.getVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVoices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.listVoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoice(voiceId, updateVoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.updateVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceApi - factory interface
 * @export
 */
export const VoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceApiFp(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneVoice(name: string, language: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<CloneVoice200Response> {
            return localVarFp.cloneVoice(name, language, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVoice200Response> {
            return localVarFp.deleteVoice(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateVoice(generateVoiceRequest: GenerateVoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.generateVoice(generateVoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.getVoice(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoices(options?: RawAxiosRequestConfig): AxiosPromise<ListVoices200Response> {
            return localVarFp.listVoices(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceApi - object-oriented interface
 * @export
 * @class VoiceApi
 * @extends {BaseAPI}
 */
export class VoiceApi extends BaseAPI {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public cloneVoice(name: string, language: string, file: File, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).cloneVoice(name, language, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public deleteVoice(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).deleteVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {GenerateVoiceRequest} generateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public generateVoice(generateVoiceRequest: GenerateVoiceRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).generateVoice(generateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public getVoice(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).getVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of voices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public listVoices(options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).listVoices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {UpdateVoiceRequest} updateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



