/* tslint:disable */
/* eslint-disable */
/**
 * Gabber API Reference
 * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * The type of the error.
     * @type {string}
     * @memberof BadRequest
     */
    'type'?: BadRequestTypeEnum;
    /**
     * A human-readable message describing the error.
     * @type {string}
     * @memberof BadRequest
     */
    'message'?: string;
}

export const BadRequestTypeEnum = {
    UsageLimitExceeded: 'usage_limit_exceeded',
    ProjectDisabled: 'project_disabled',
    ModerationError: 'moderation_error',
    InvalidInput: 'invalid_input'
} as const;

export type BadRequestTypeEnum = typeof BadRequestTypeEnum[keyof typeof BadRequestTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletionRequest
 */
export interface ChatCompletionRequest {
    /**
     * Chat context
     * @type {Array<ChatCompletionRequestMessage>}
     * @memberof ChatCompletionRequest
     */
    'messages': Array<ChatCompletionRequestMessage>;
    /**
     * Gabber llm_id
     * @type {string}
     * @memberof ChatCompletionRequest
     */
    'model': string;
    /**
     * 
     * @type {object}
     * @memberof ChatCompletionRequest
     */
    'metadata'?: object;
    /**
     * 
     * @type {ChatCompletionRequestGabber}
     * @memberof ChatCompletionRequest
     */
    'gabber'?: ChatCompletionRequestGabber;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. 
     * @type {boolean}
     * @memberof ChatCompletionRequest
     */
    'stream'?: boolean;
    /**
     * Temperature for sampling from the model. Higher values mean more randomness. 
     * @type {number}
     * @memberof ChatCompletionRequest
     */
    'temperature'?: number;
    /**
     * Maximum number of tokens to generate. Requests can be up to 4096 tokens. 
     * @type {number}
     * @memberof ChatCompletionRequest
     */
    'max_tokens'?: number;
}
/**
 * 
 * @export
 * @interface ChatCompletionRequestGabber
 */
export interface ChatCompletionRequestGabber {
    /**
     * Gabber voice id
     * @type {string}
     * @memberof ChatCompletionRequestGabber
     */
    'voice'?: string;
}
/**
 * 
 * @export
 * @interface ChatCompletionRequestMessage
 */
export interface ChatCompletionRequestMessage {
    /**
     * 
     * @type {ChatCompletionRequestMessageContent}
     * @memberof ChatCompletionRequestMessage
     */
    'content': ChatCompletionRequestMessageContent;
    /**
     * The role of the messages author.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    'role': ChatCompletionRequestMessageRoleEnum;
}

export const ChatCompletionRequestMessageRoleEnum = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type ChatCompletionRequestMessageRoleEnum = typeof ChatCompletionRequestMessageRoleEnum[keyof typeof ChatCompletionRequestMessageRoleEnum];

/**
 * @type ChatCompletionRequestMessageContent
 * The contents of the message.
 * @export
 */
export type ChatCompletionRequestMessageContent = Array<ChatCompletionRequestUserMessageContentPart> | string;

/**
 * 
 * @export
 * @interface ChatCompletionRequestMessageContentPartAudio
 */
export interface ChatCompletionRequestMessageContentPartAudio {
    /**
     * Audio content type.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudio
     */
    'type': ChatCompletionRequestMessageContentPartAudioTypeEnum;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartAudioInputAudio}
     * @memberof ChatCompletionRequestMessageContentPartAudio
     */
    'input_audio': ChatCompletionRequestMessageContentPartAudioInputAudio;
}

export const ChatCompletionRequestMessageContentPartAudioTypeEnum = {
    InputAudio: 'input_audio'
} as const;

export type ChatCompletionRequestMessageContentPartAudioTypeEnum = typeof ChatCompletionRequestMessageContentPartAudioTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletionRequestMessageContentPartAudioInputAudio
 */
export interface ChatCompletionRequestMessageContentPartAudioInputAudio {
    /**
     * Base64 encoded audio data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio
     */
    'data': string;
    /**
     * The format of the audio data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio
     */
    'format': ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum;
}

export const ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = {
    Wav: 'wav',
    Mp3: 'mp3',
    Ogg: 'ogg'
} as const;

export type ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum];

/**
 * Text content
 * @export
 * @interface ChatCompletionRequestMessageContentPartText
 */
export interface ChatCompletionRequestMessageContentPartText {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    'type': ChatCompletionRequestMessageContentPartTextTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    'text': string;
}

export const ChatCompletionRequestMessageContentPartTextTypeEnum = {
    Text: 'text'
} as const;

export type ChatCompletionRequestMessageContentPartTextTypeEnum = typeof ChatCompletionRequestMessageContentPartTextTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartTextTypeEnum];

/**
 * @type ChatCompletionRequestUserMessageContentPart
 * @export
 */
export type ChatCompletionRequestUserMessageContentPart = ChatCompletionRequestMessageContentPartAudio | ChatCompletionRequestMessageContentPartText;

/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape. 
 * @export
 * @interface ChatCompletionResponse
 */
export interface ChatCompletionResponse {
    /**
     * A list of chat completion choices.
     * @type {Array<ChatCompletionResponseChoicesInner>}
     * @memberof ChatCompletionResponse
     */
    'choices': Array<ChatCompletionResponseChoicesInner>;
    /**
     * The model used for completion.
     * @type {string}
     * @memberof ChatCompletionResponse
     */
    'model': string;
    /**
     * 
     * @type {ChatCompletionResponseGabber}
     * @memberof ChatCompletionResponse
     */
    'gabber'?: ChatCompletionResponseGabber;
}
/**
 * 
 * @export
 * @interface ChatCompletionResponseChoicesInner
 */
export interface ChatCompletionResponseChoicesInner {
    /**
     * 
     * @type {ChatCompletionResponseMessage}
     * @memberof ChatCompletionResponseChoicesInner
     */
    'message': ChatCompletionResponseMessage;
}
/**
 * Gabber-specific fields
 * @export
 * @interface ChatCompletionResponseGabber
 */
export interface ChatCompletionResponseGabber {
    /**
     * Gabber usage for this request
     * @type {Array<Usage>}
     * @memberof ChatCompletionResponseGabber
     */
    'usage': Array<Usage>;
    /**
     * 
     * @type {Array<ChatCompletionResponseGabberMessageData>}
     * @memberof ChatCompletionResponseGabber
     */
    'message_data': Array<ChatCompletionResponseGabberMessageData>;
}
/**
 * 
 * @export
 * @interface ChatCompletionResponseGabberMessageData
 */
export interface ChatCompletionResponseGabberMessageData {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionResponseGabberMessageData
     */
    'message_index': number;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionResponseGabberMessageData
     */
    'content_index': number;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionResponseGabberMessageData
     */
    'type': ChatCompletionResponseGabberMessageDataTypeEnum;
    /**
     * 
     * @type {ChatCompletionResponseGabberMessageDataData}
     * @memberof ChatCompletionResponseGabberMessageData
     */
    'data': ChatCompletionResponseGabberMessageDataData;
}

export const ChatCompletionResponseGabberMessageDataTypeEnum = {
    AudioTranscript: 'audio_transcript'
} as const;

export type ChatCompletionResponseGabberMessageDataTypeEnum = typeof ChatCompletionResponseGabberMessageDataTypeEnum[keyof typeof ChatCompletionResponseGabberMessageDataTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletionResponseGabberMessageDataData
 */
export interface ChatCompletionResponseGabberMessageDataData {
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionResponseGabberMessageDataData
     */
    'transcript': string;
}
/**
 * A chat completion message generated by the model.
 * @export
 * @interface ChatCompletionResponseMessage
 */
export interface ChatCompletionResponseMessage {
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'content': string;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'refusal': string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * 
     * @type {ChatCompletionResponseMessageGabber}
     * @memberof ChatCompletionResponseMessage
     */
    'gabber'?: ChatCompletionResponseMessageGabber;
}

export const ChatCompletionResponseMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ChatCompletionResponseMessageRoleEnum = typeof ChatCompletionResponseMessageRoleEnum[keyof typeof ChatCompletionResponseMessageRoleEnum];

/**
 * If the audio output modality is requested, this object contains data
 * @export
 * @interface ChatCompletionResponseMessageGabber
 */
export interface ChatCompletionResponseMessageGabber {
    /**
     * 
     * @type {ChatCompletionResponseMessageGabberVoice}
     * @memberof ChatCompletionResponseMessageGabber
     */
    'voice'?: ChatCompletionResponseMessageGabberVoice;
}
/**
 * 
 * @export
 * @interface ChatCompletionResponseMessageGabberVoice
 */
export interface ChatCompletionResponseMessageGabberVoice {
    /**
     * This will be the URL to the audio file
     * @type {string}
     * @memberof ChatCompletionResponseMessageGabberVoice
     */
    'audio_url': string;
    /**
     * The Unix timestamp (in seconds) when the audio file expires
     * @type {number}
     * @memberof ChatCompletionResponseMessageGabberVoice
     */
    'expires_at': number;
}
/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 * @export
 * @interface ChatCompletionStreamResponse
 */
export interface ChatCompletionStreamResponse {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     * @type {string}
     * @memberof ChatCompletionStreamResponse
     */
    'id': string;
    /**
     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
     * @type {Array<ChatCompletionStreamResponseChoice>}
     * @memberof ChatCompletionStreamResponse
     */
    'choices': Array<ChatCompletionStreamResponseChoice>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     * @type {number}
     * @memberof ChatCompletionStreamResponse
     */
    'created': number;
    /**
     * The model to generate the completion.
     * @type {string}
     * @memberof ChatCompletionStreamResponse
     */
    'model': string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     * @type {string}
     * @memberof ChatCompletionStreamResponse
     */
    'object': ChatCompletionStreamResponseObjectEnum;
    /**
     * 
     * @type {ChatCompletionResponseGabber}
     * @memberof ChatCompletionStreamResponse
     */
    'gabber'?: ChatCompletionResponseGabber;
}

export const ChatCompletionStreamResponseObjectEnum = {
    ChatCompletionChunk: 'chat.completion.chunk'
} as const;

export type ChatCompletionStreamResponseObjectEnum = typeof ChatCompletionStreamResponseObjectEnum[keyof typeof ChatCompletionStreamResponseObjectEnum];

/**
 * 
 * @export
 * @interface ChatCompletionStreamResponseChoice
 */
export interface ChatCompletionStreamResponseChoice {
    /**
     * 
     * @type {ChatCompletionStreamResponseDelta}
     * @memberof ChatCompletionStreamResponseChoice
     */
    'delta': ChatCompletionStreamResponseDelta;
    /**
     * The reason the model stopped generating tokens.
     * @type {string}
     * @memberof ChatCompletionStreamResponseChoice
     */
    'finish_reason': ChatCompletionStreamResponseChoiceFinishReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionStreamResponseChoice
     */
    'index': number;
}

export const ChatCompletionStreamResponseChoiceFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ToolCalls: 'tool_calls',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
} as const;

export type ChatCompletionStreamResponseChoiceFinishReasonEnum = typeof ChatCompletionStreamResponseChoiceFinishReasonEnum[keyof typeof ChatCompletionStreamResponseChoiceFinishReasonEnum];

/**
 * A chat completion delta generated by streamed model responses.
 * @export
 * @interface ChatCompletionStreamResponseDelta
 */
export interface ChatCompletionStreamResponseDelta {
    /**
     * The contents of the chunk message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'content': string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'role': ChatCompletionStreamResponseDeltaRoleEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'refusal'?: string;
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaGabber}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'gabber'?: ChatCompletionStreamResponseDeltaGabber;
}

export const ChatCompletionStreamResponseDeltaRoleEnum = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant'
} as const;

export type ChatCompletionStreamResponseDeltaRoleEnum = typeof ChatCompletionStreamResponseDeltaRoleEnum[keyof typeof ChatCompletionStreamResponseDeltaRoleEnum];

/**
 * If the audio output modality is requested, this object contains data
 * @export
 * @interface ChatCompletionStreamResponseDeltaGabber
 */
export interface ChatCompletionStreamResponseDeltaGabber {
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaGabberVoice}
     * @memberof ChatCompletionStreamResponseDeltaGabber
     */
    'voice'?: ChatCompletionStreamResponseDeltaGabberVoice;
}
/**
 * 
 * @export
 * @interface ChatCompletionStreamResponseDeltaGabberVoice
 */
export interface ChatCompletionStreamResponseDeltaGabberVoice {
    /**
     * This will be the URL to the audio file
     * @type {string}
     * @memberof ChatCompletionStreamResponseDeltaGabberVoice
     */
    'audio_url': string;
    /**
     * The Unix timestamp (in seconds) when the audio file expires
     * @type {number}
     * @memberof ChatCompletionStreamResponseDeltaGabberVoice
     */
    'expires_at': number;
}
/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'human'?: string;
}
/**
 * 
 * @export
 * @interface ContextCreateRequest
 */
export interface ContextCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequest
     */
    'persona'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequest
     */
    'scenario'?: string;
    /**
     * 
     * @type {Array<ContextCreateRequestMessagesInner>}
     * @memberof ContextCreateRequest
     */
    'messages'?: Array<ContextCreateRequestMessagesInner>;
}
/**
 * 
 * @export
 * @interface ContextCreateRequestMessagesInner
 */
export interface ContextCreateRequestMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequestMessagesInner
     */
    'role': ContextCreateRequestMessagesInnerRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequestMessagesInner
     */
    'content': string;
}

export const ContextCreateRequestMessagesInnerRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextCreateRequestMessagesInnerRoleEnum = typeof ContextCreateRequestMessagesInnerRoleEnum[keyof typeof ContextCreateRequestMessagesInnerRoleEnum];

/**
 * 
 * @export
 * @interface ContextMessage
 */
export interface ContextMessage {
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'speaking_ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'speaking_started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'role': ContextMessageRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'created_at': string;
}

export const ContextMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextMessageRoleEnum = typeof ContextMessageRoleEnum[keyof typeof ContextMessageRoleEnum];

/**
 * 
 * @export
 * @interface ContextMessageCreateParams
 */
export interface ContextMessageCreateParams {
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'speaking_ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'speaking_started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'role': ContextMessageCreateParamsRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'content': string;
}

export const ContextMessageCreateParamsRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextMessageCreateParamsRoleEnum = typeof ContextMessageCreateParamsRoleEnum[keyof typeof ContextMessageCreateParamsRoleEnum];

/**
 * 
 * @export
 * @interface CreateCreditLedgerEntryRequest
 */
export interface CreateCreditLedgerEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * The name of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof CreateCreditRequest
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreatePersonaRequest
 */
export interface CreatePersonaRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'gender'?: CreatePersonaRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'voice': string;
}

export const CreatePersonaRequestGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type CreatePersonaRequestGenderEnum = typeof CreatePersonaRequestGenderEnum[keyof typeof CreatePersonaRequestGenderEnum];

/**
 * 
 * @export
 * @interface CreateScenarioRequest
 */
export interface CreateScenarioRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface CreateUsageToken200Response
 */
export interface CreateUsageToken200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateUsageToken200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * The date and time the credit was created.
     * @type {string}
     * @memberof Credit
     */
    'created_at': string;
    /**
     * The unique identifier of the credit.
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * The project the credit belongs to.
     * @type {string}
     * @memberof Credit
     */
    'project': string;
    /**
     * The name of the credit.
     * @type {string}
     * @memberof Credit
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof Credit
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof Credit
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreditLedgerEntry
 */
export interface CreditLedgerEntry {
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'credit': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'human': string;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface DeletePersona200Response
 */
export interface DeletePersona200Response {
    /**
     * 
     * @type {string}
     * @memberof DeletePersona200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteScenario200Response
 */
export interface DeleteScenario200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteScenario200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteVoice200Response
 */
export interface DeleteVoice200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteVoice200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DummyGet200Response
 */
export interface DummyGet200Response {
    /**
     * 
     * @type {WebhookMessage}
     * @memberof DummyGet200Response
     */
    'webhook_message'?: WebhookMessage;
}
/**
 * 
 * @export
 * @interface GenerateVoiceRequest
 */
export interface GenerateVoiceRequest {
    /**
     * Text to synthesize into voice
     * @type {string}
     * @memberof GenerateVoiceRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateVoiceRequest
     */
    'voice_id': string;
    /**
     * Whether to moderate the text.
     * @type {boolean}
     * @memberof GenerateVoiceRequest
     */
    'moderation'?: boolean;
}
/**
 * 
 * @export
 * @interface GetRealtimeSessionMessages200Response
 */
export interface GetRealtimeSessionMessages200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof GetRealtimeSessionMessages200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof GetRealtimeSessionMessages200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<ContextMessage>}
     * @memberof GetRealtimeSessionMessages200Response
     */
    'values': Array<ContextMessage>;
}
/**
 * 
 * @export
 * @interface GetRealtimeSessionTimeline200Response
 */
export interface GetRealtimeSessionTimeline200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof GetRealtimeSessionTimeline200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof GetRealtimeSessionTimeline200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<RealtimeSessionTimelineItem>}
     * @memberof GetRealtimeSessionTimeline200Response
     */
    'values': Array<RealtimeSessionTimelineItem>;
}
/**
 * 
 * @export
 * @interface HistoryMessage
 */
export interface HistoryMessage {
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'role': HistoryMessageRoleEnum;
}

export const HistoryMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type HistoryMessageRoleEnum = typeof HistoryMessageRoleEnum[keyof typeof HistoryMessageRoleEnum];

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Error message.
     * @type {string}
     * @memberof InlineObject
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface LLM
 */
export interface LLM {
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof LLM
     */
    'compliance': boolean;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ListContextMessages200Response
 */
export interface ListContextMessages200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof ListContextMessages200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof ListContextMessages200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<ContextMessage>}
     * @memberof ListContextMessages200Response
     */
    'values': Array<ContextMessage>;
}
/**
 * 
 * @export
 * @interface ListCredits200Response
 */
export interface ListCredits200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListCredits200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListCredits200Response
     */
    'total_count': number;
    /**
     * The array of credits.
     * @type {Array<Credit>}
     * @memberof ListCredits200Response
     */
    'values': Array<Credit>;
}
/**
 * 
 * @export
 * @interface ListLLMs200Response
 */
export interface ListLLMs200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListLLMs200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListLLMs200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<LLM>}
     * @memberof ListLLMs200Response
     */
    'values': Array<LLM>;
}
/**
 * 
 * @export
 * @interface ListPersonas200Response
 */
export interface ListPersonas200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListPersonas200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListPersonas200Response
     */
    'total_count': number;
    /**
     * The array of personas.
     * @type {Array<Persona>}
     * @memberof ListPersonas200Response
     */
    'values': Array<Persona>;
}
/**
 * 
 * @export
 * @interface ListRealtimeSessions200Response
 */
export interface ListRealtimeSessions200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof ListRealtimeSessions200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof ListRealtimeSessions200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<RealtimeSession>}
     * @memberof ListRealtimeSessions200Response
     */
    'values': Array<RealtimeSession>;
}
/**
 * 
 * @export
 * @interface ListScenarios200Response
 */
export interface ListScenarios200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListScenarios200Response
     */
    'next_page'?: string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListScenarios200Response
     */
    'total_count': number;
    /**
     * The array of scenarios.
     * @type {Array<Scenario>}
     * @memberof ListScenarios200Response
     */
    'values': Array<Scenario>;
}
/**
 * 
 * @export
 * @interface ListVoices200Response
 */
export interface ListVoices200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListVoices200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListVoices200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<Voice>}
     * @memberof ListVoices200Response
     */
    'values': Array<Voice>;
}
/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'human'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {Array<PersonaTagsInner>}
     * @memberof Persona
     */
    'tags'?: Array<PersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'voice': string;
}

export const PersonaGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type PersonaGenderEnum = typeof PersonaGenderEnum[keyof typeof PersonaGenderEnum];

/**
 * 
 * @export
 * @interface PersonaTagsInner
 */
export interface PersonaTagsInner {
    /**
     * 
     * @type {string}
     * @memberof PersonaTagsInner
     */
    'human_name': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaTagsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface RealtimeSession
 */
export interface RealtimeSession {
    /**
     * The unique identifier of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSession
     */
    'id': string;
    /**
     * The current state of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSession
     */
    'state': RealtimeSessionStateEnum;
    /**
     * The time the RealtimeSession was created.
     * @type {string}
     * @memberof RealtimeSession
     */
    'created_at': string;
    /**
     * The time the RealtimeSession ended.
     * @type {string}
     * @memberof RealtimeSession
     */
    'ended_at'?: string;
    /**
     * The project identifier.
     * @type {string}
     * @memberof RealtimeSession
     */
    'project': string;
    /**
     * The human identifier.
     * @type {string}
     * @memberof RealtimeSession
     */
    'human'?: string;
    /**
     * Whether the session is simulated or not.
     * @type {boolean}
     * @memberof RealtimeSession
     */
    'simulated': boolean;
    /**
     * 
     * @type {RealtimeSessionConfig}
     * @memberof RealtimeSession
     */
    'config': RealtimeSessionConfig;
}

export const RealtimeSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type RealtimeSessionStateEnum = typeof RealtimeSessionStateEnum[keyof typeof RealtimeSessionStateEnum];

/**
 * 
 * @export
 * @interface RealtimeSessionConfig
 */
export interface RealtimeSessionConfig {
    /**
     * 
     * @type {RealtimeSessionGeneralConfig}
     * @memberof RealtimeSessionConfig
     */
    'general': RealtimeSessionGeneralConfig;
    /**
     * 
     * @type {RealtimeSessionInputConfig}
     * @memberof RealtimeSessionConfig
     */
    'input': RealtimeSessionInputConfig;
    /**
     * 
     * @type {RealtimeSessionGenerativeConfig}
     * @memberof RealtimeSessionConfig
     */
    'generative': RealtimeSessionGenerativeConfig;
    /**
     * 
     * @type {RealtimeSessionOutputConfig}
     * @memberof RealtimeSessionConfig
     */
    'output': RealtimeSessionOutputConfig;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigCreate
 */
export interface RealtimeSessionConfigCreate {
    /**
     * 
     * @type {RealtimeSessionGeneralConfig}
     * @memberof RealtimeSessionConfigCreate
     */
    'general': RealtimeSessionGeneralConfig;
    /**
     * 
     * @type {RealtimeSessionInputConfig}
     * @memberof RealtimeSessionConfigCreate
     */
    'input': RealtimeSessionInputConfig;
    /**
     * 
     * @type {RealtimeSessionGenerativeConfigCreate}
     * @memberof RealtimeSessionConfigCreate
     */
    'generative': RealtimeSessionGenerativeConfigCreate;
    /**
     * 
     * @type {RealtimeSessionOutputConfig}
     * @memberof RealtimeSessionConfigCreate
     */
    'output': RealtimeSessionOutputConfig;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigUpdate
 */
export interface RealtimeSessionConfigUpdate {
    /**
     * 
     * @type {RealtimeSessionGeneralConfig}
     * @memberof RealtimeSessionConfigUpdate
     */
    'general'?: RealtimeSessionGeneralConfig;
    /**
     * 
     * @type {RealtimeSessionInputConfig}
     * @memberof RealtimeSessionConfigUpdate
     */
    'input'?: RealtimeSessionInputConfig;
    /**
     * 
     * @type {RealtimeSessionGenerativeConfigUpdate}
     * @memberof RealtimeSessionConfigUpdate
     */
    'generative'?: RealtimeSessionGenerativeConfigUpdate;
    /**
     * 
     * @type {RealtimeSessionOutputConfig}
     * @memberof RealtimeSessionConfigUpdate
     */
    'output'?: RealtimeSessionOutputConfig;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConnectionDetails
 */
export interface RealtimeSessionConnectionDetails {
    /**
     * The URL to connect to the RealtimeSession
     * @type {string}
     * @memberof RealtimeSessionConnectionDetails
     */
    'url': string;
    /**
     * The token to use to connect to the RealtimeSession
     * @type {string}
     * @memberof RealtimeSessionConnectionDetails
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RealtimeSessionGeneralConfig
 */
export interface RealtimeSessionGeneralConfig {
    /**
     * The time limit in seconds for the RealtimeSession.
     * @type {number}
     * @memberof RealtimeSessionGeneralConfig
     */
    'time_limit_s'?: number;
    /**
     * Whether to save messages in the RealtimeSession. These will be saved to the context provided in the generative config. If no context is provided, a new context will be created when the session starts. 
     * @type {boolean}
     * @memberof RealtimeSessionGeneralConfig
     */
    'save_messages': boolean;
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionGenerativeConfig
 */
export interface RealtimeSessionGenerativeConfig {
    /**
     * 
     * @type {LLM}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'llm': LLM;
    /**
     * 
     * @type {Voice}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'voice_override'?: Voice;
    /**
     * 
     * @type {Persona}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'persona'?: Persona;
    /**
     * 
     * @type {Scenario}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'scenario'?: Scenario;
    /**
     * 
     * @type {Context}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'context': Context;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {object}
     * @memberof RealtimeSessionGenerativeConfig
     */
    '_extra'?: object;
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionGenerativeConfigCreate
 */
export interface RealtimeSessionGenerativeConfigCreate {
    /**
     * The LLM to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'llm': string;
    /**
     * The voice to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'voice_override'?: string;
    /**
     * The persona to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'persona'?: string;
    /**
     * The scenario to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'scenario'?: string;
    /**
     * The context to use for the RealtimeSession. If unspecified, a new context will be created.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'context'?: string;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {object}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    '_extra'?: object;
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionGenerativeConfigUpdate
 */
export interface RealtimeSessionGenerativeConfigUpdate {
    /**
     * The LLM to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'llm'?: string;
    /**
     * The voice to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'voice_override'?: string;
    /**
     * The persona to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'persona'?: string;
    /**
     * The scenario to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'scenario'?: string;
    /**
     * The context to use for the RealtimeSession. If unspecified, a new context will be created.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'context'?: string;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {object}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    '_extra'?: object;
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionInputConfig
 */
export interface RealtimeSessionInputConfig {
    /**
     * Whether the system allows interruption during speech.
     * @type {boolean}
     * @memberof RealtimeSessionInputConfig
     */
    'interruptable': boolean;
    /**
     * Whether the AI should continue listening while speaking. If true, the AI will produce another response immediately after the first one. This is only relevant if interruptable is false. 
     * @type {boolean}
     * @memberof RealtimeSessionInputConfig
     */
    'parallel_listening': boolean;
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionOutputConfig
 */
export interface RealtimeSessionOutputConfig {
    /**
     * Whether to stream AI spoken transcript or send full transcript when it\'s available all at once.
     * @type {boolean}
     * @memberof RealtimeSessionOutputConfig
     */
    'stream_transcript': boolean;
    /**
     * Whether to enable speech synthesis for the RealtimeSession.
     * @type {boolean}
     * @memberof RealtimeSessionOutputConfig
     */
    'speech_synthesis_enabled': boolean;
}
/**
 * 
 * @export
 * @interface RealtimeSessionStartResponse
 */
export interface RealtimeSessionStartResponse {
    /**
     * 
     * @type {RealtimeSession}
     * @memberof RealtimeSessionStartResponse
     */
    'session': RealtimeSession;
    /**
     * 
     * @type {RealtimeSessionConnectionDetails}
     * @memberof RealtimeSessionStartResponse
     */
    'connection_details': RealtimeSessionConnectionDetails;
}
/**
 * 
 * @export
 * @interface RealtimeSessionTimelineItem
 */
export interface RealtimeSessionTimelineItem {
    /**
     * 
     * @type {number}
     * @memberof RealtimeSessionTimelineItem
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof RealtimeSessionTimelineItem
     */
    'type'?: RealtimeSessionTimelineItemTypeEnum;
}

export const RealtimeSessionTimelineItemTypeEnum = {
    Silence: 'silence',
    Agent: 'agent',
    User: 'user'
} as const;

export type RealtimeSessionTimelineItemTypeEnum = typeof RealtimeSessionTimelineItemTypeEnum[keyof typeof RealtimeSessionTimelineItemTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const SDKAgentState = {
    Warmup: 'warmup',
    Listening: 'listening',
    Thinking: 'thinking',
    Speaking: 'speaking',
    TimeLimitExceeded: 'time_limit_exceeded',
    UsageLimitExceeded: 'usage_limit_exceeded'
} as const;

export type SDKAgentState = typeof SDKAgentState[keyof typeof SDKAgentState];


/**
 * @type SDKConnectOptions
 * @export
 */
export type SDKConnectOptions = SDKConnectOptionsOneOf | SDKConnectOptionsOneOf1;

/**
 * 
 * @export
 * @interface SDKConnectOptionsOneOf
 */
export interface SDKConnectOptionsOneOf {
    /**
     * 
     * @type {RealtimeSessionConnectionDetails}
     * @memberof SDKConnectOptionsOneOf
     */
    'connection_details': RealtimeSessionConnectionDetails;
}
/**
 * 
 * @export
 * @interface SDKConnectOptionsOneOf1
 */
export interface SDKConnectOptionsOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof SDKConnectOptionsOneOf1
     */
    'token': string;
    /**
     * 
     * @type {RealtimeSessionConfigCreate}
     * @memberof SDKConnectOptionsOneOf1
     */
    'config': RealtimeSessionConfigCreate;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SDKConnectionState = {
    NotConnected: 'not_connected',
    Connecting: 'connecting',
    WaitingForAgent: 'waiting_for_agent',
    Connected: 'connected'
} as const;

export type SDKConnectionState = typeof SDKConnectionState[keyof typeof SDKConnectionState];


/**
 * 
 * @export
 * @interface SDKSendChatMessageParams
 */
export interface SDKSendChatMessageParams {
    /**
     * 
     * @type {string}
     * @memberof SDKSendChatMessageParams
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface SDKSessionTranscription
 */
export interface SDKSessionTranscription {
    /**
     * 
     * @type {string}
     * @memberof SDKSessionTranscription
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof SDKSessionTranscription
     */
    'agent': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SDKSessionTranscription
     */
    'final': boolean;
    /**
     * 
     * @type {string}
     * @memberof SDKSessionTranscription
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SDKSessionTranscription
     */
    'speaking_ended_at': string;
    /**
     * 
     * @type {string}
     * @memberof SDKSessionTranscription
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'human'?: string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof Session
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'state': SessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'time_limit_s': number;
}

export const SessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type SessionStateEnum = typeof SessionStateEnum[keyof typeof SessionStateEnum];

/**
 * 
 * @export
 * @interface SessionMessage
 */
export interface SessionMessage {
    /**
     * 
     * @type {boolean}
     * @memberof SessionMessage
     */
    'agent': boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'import_id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'media'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'session': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'speaking_ended_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'text'?: string;
}
/**
 * @type SessionStartRequest
 * @export
 */
export type SessionStartRequest = SessionStartRequestOneOf | SessionStartRequestOneOf1;

/**
 * 
 * @export
 * @interface SessionStartRequestOneOf
 */
export interface SessionStartRequestOneOf {
    /**
     * 
     * @type {Array<HistoryMessage>}
     * @memberof SessionStartRequestOneOf
     */
    'history'?: Array<HistoryMessage>;
    /**
     * 
     * @type {number}
     * @memberof SessionStartRequestOneOf
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof SessionStartRequestOneOf
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof SessionStartRequestOneOf
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface SessionStartRequestOneOf1
 */
export interface SessionStartRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof SessionStartRequestOneOf1
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'scenario'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof SessionStartRequestOneOf1
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof SessionStartRequestOneOf1
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface SessionStartResponse
 */
export interface SessionStartResponse {
    /**
     * 
     * @type {Session}
     * @memberof SessionStartResponse
     */
    'session': Session;
    /**
     * 
     * @type {Persona}
     * @memberof SessionStartResponse
     */
    'persona'?: Persona;
    /**
     * 
     * @type {Scenario}
     * @memberof SessionStartResponse
     */
    'scenario'?: Scenario;
    /**
     * 
     * @type {SessionStartResponseConnectionDetails}
     * @memberof SessionStartResponse
     */
    'connection_details': SessionStartResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface SessionStartResponseConnectionDetails
 */
export interface SessionStartResponseConnectionDetails {
    /**
     * 
     * @type {string}
     * @memberof SessionStartResponseConnectionDetails
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartResponseConnectionDetails
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SessionTimelineItem
 */
export interface SessionTimelineItem {
    /**
     * 
     * @type {number}
     * @memberof SessionTimelineItem
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionTimelineItem
     */
    'type'?: SessionTimelineItemTypeEnum;
}

export const SessionTimelineItemTypeEnum = {
    Silence: 'silence',
    Agent: 'agent',
    User: 'user'
} as const;

export type SessionTimelineItemTypeEnum = typeof SessionTimelineItemTypeEnum[keyof typeof SessionTimelineItemTypeEnum];

/**
 * 
 * @export
 * @interface StartRealtimeSessionRequest
 */
export interface StartRealtimeSessionRequest {
    /**
     * Whether the session is simulated.
     * @type {boolean}
     * @memberof StartRealtimeSessionRequest
     */
    'simulated'?: boolean;
    /**
     * 
     * @type {RealtimeSessionConfigCreate}
     * @memberof StartRealtimeSessionRequest
     */
    'config': RealtimeSessionConfigCreate;
}
/**
 * 
 * @export
 * @interface UpdatePersonaRequest
 */
export interface UpdatePersonaRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'gender'?: UpdatePersonaRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'voice'?: string;
}

export const UpdatePersonaRequestGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type UpdatePersonaRequestGenderEnum = typeof UpdatePersonaRequestGenderEnum[keyof typeof UpdatePersonaRequestGenderEnum];

/**
 * 
 * @export
 * @interface UpdateScenarioRequest
 */
export interface UpdateScenarioRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'prompt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSessionRequest
 */
export interface UpdateSessionRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateSessionRequest
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateSessionRequest
     */
    'voice_override'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUsageLimitsRequest
 */
export interface UpdateUsageLimitsRequest {
    /**
     * 
     * @type {Array<UsageLimitsInner>}
     * @memberof UpdateUsageLimitsRequest
     */
    'limits': Array<UsageLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof UpdateUsageLimitsRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @interface UpdateVoiceRequest
 */
export interface UpdateVoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateVoiceRequest
     */
    'name': string;
    /**
     * The language of the voice
     * @type {string}
     * @memberof UpdateVoiceRequest
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    'id': string;
    /**
     * 
     * @type {UsageType}
     * @memberof Usage
     */
    'type': UsageType;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    'human'?: string;
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    'project': string;
    /**
     * 
     * @type {object}
     * @memberof Usage
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface UsageLimitsInner
 */
export interface UsageLimitsInner {
    /**
     * 
     * @type {UsageType}
     * @memberof UsageLimitsInner
     */
    'type': UsageType;
    /**
     * 
     * @type {number}
     * @memberof UsageLimitsInner
     */
    'value': number;
}


/**
 * 
 * @export
 * @interface UsageTokenRequest
 */
export interface UsageTokenRequest {
    /**
     * 
     * @type {Array<UsageLimitsInner>}
     * @memberof UsageTokenRequest
     */
    'limits': Array<UsageLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof UsageTokenRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UsageType = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * 
 * @export
 * @interface Voice
 */
export interface Voice {
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'voice'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Voice
     */
    'embeddings'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'cartesia_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'elevenlabs_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'human'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'preview_url'?: string;
    /**
     * Extra configuration for the voice. Usually this is for internal purposes.
     * @type {object}
     * @memberof Voice
     */
    '_extra'?: object;
}
/**
 * @type WebhookMessage
 * @export
 */
export type WebhookMessage = WebhookMessageRealtimeSessionStateChanged | WebhookMessageUsageTracked;

/**
 * 
 * @export
 * @interface WebhookMessageRealtimeSessionStateChanged
 */
export interface WebhookMessageRealtimeSessionStateChanged {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageRealtimeSessionStateChanged
     */
    'type': WebhookMessageRealtimeSessionStateChangedTypeEnum;
    /**
     * 
     * @type {WebhookMessageRealtimeSessionStateChangedPayload}
     * @memberof WebhookMessageRealtimeSessionStateChanged
     */
    'payload': WebhookMessageRealtimeSessionStateChangedPayload;
}

export const WebhookMessageRealtimeSessionStateChangedTypeEnum = {
    RealtimeSessionStateChanged: 'realtime_session.state_changed'
} as const;

export type WebhookMessageRealtimeSessionStateChangedTypeEnum = typeof WebhookMessageRealtimeSessionStateChangedTypeEnum[keyof typeof WebhookMessageRealtimeSessionStateChangedTypeEnum];

/**
 * 
 * @export
 * @interface WebhookMessageRealtimeSessionStateChangedPayload
 */
export interface WebhookMessageRealtimeSessionStateChangedPayload {
    /**
     * 
     * @type {WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession}
     * @memberof WebhookMessageRealtimeSessionStateChangedPayload
     */
    'previous_realtime_session'?: WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession;
    /**
     * 
     * @type {WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession}
     * @memberof WebhookMessageRealtimeSessionStateChangedPayload
     */
    'current_realtime_session'?: WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession;
}
/**
 * 
 * @export
 * @interface WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession
 */
export interface WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSession
     */
    'state'?: WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSessionStateEnum;
}

export const WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSessionStateEnum = {
    NotStarted: 'not_started',
    InProgress: 'in_progress',
    Ended: 'ended'
} as const;

export type WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSessionStateEnum = typeof WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSessionStateEnum[keyof typeof WebhookMessageRealtimeSessionStateChangedPayloadPreviousRealtimeSessionStateEnum];

/**
 * 
 * @export
 * @interface WebhookMessageUsageTracked
 */
export interface WebhookMessageUsageTracked {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageUsageTracked
     */
    'type': WebhookMessageUsageTrackedTypeEnum;
    /**
     * 
     * @type {WebhookMessageUsageTrackedPayload}
     * @memberof WebhookMessageUsageTracked
     */
    'payload': WebhookMessageUsageTrackedPayload;
}

export const WebhookMessageUsageTrackedTypeEnum = {
    UsageTracked: 'usage.tracked'
} as const;

export type WebhookMessageUsageTrackedTypeEnum = typeof WebhookMessageUsageTrackedTypeEnum[keyof typeof WebhookMessageUsageTrackedTypeEnum];

/**
 * 
 * @export
 * @interface WebhookMessageUsageTrackedPayload
 */
export interface WebhookMessageUsageTrackedPayload {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'id': string;
    /**
     * 
     * @type {UsageType}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'type': UsageType;
    /**
     * 
     * @type {number}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'human'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'project': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'metadata'?: object;
    /**
     * Use `human` instead.
     * @type {string}
     * @memberof WebhookMessageUsageTrackedPayload
     * @deprecated
     */
    'human_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'extra'?: object;
}



/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new credit based on the input request data. 
         * @summary Create a new credit type
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit: async (createCreditRequest: CreateCreditRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCreditRequest' is not null or undefined
            assertParamExists('createCredit', 'createCreditRequest', createCreditRequest)
            const localVarPath = `/v1/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCreditLedgerEntry: async (credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('createCreditLedgerEntry', 'credit', credit)
            // verify required parameter 'createCreditLedgerEntryRequest' is not null or undefined
            assertParamExists('createCreditLedgerEntry', 'createCreditLedgerEntryRequest', createCreditLedgerEntryRequest)
            const localVarPath = `/v1/credit/{credit}/ledger`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditLedgerEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit: async (credit: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('getCredit', 'credit', credit)
            const localVarPath = `/v1/credit/{credit}`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCreditLedgerEntry: async (credit: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('getLatestCreditLedgerEntry', 'credit', credit)
            const localVarPath = `/v1/credit/{credit}/ledger/latest`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/credit/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new credit based on the input request data. 
         * @summary Create a new credit type
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredit(createCreditRequest: CreateCreditRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredit(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredit(credit, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestCreditLedgerEntry(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestCreditLedgerEntry(credit, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getLatestCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredits(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCredits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.listCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditApiFp(configuration)
    return {
        /**
         * Creates a new credit based on the input request data. 
         * @summary Create a new credit type
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit(createCreditRequest: CreateCreditRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.createCredit(createCreditRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.getCredit(credit, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCreditLedgerEntry(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.getLatestCreditLedgerEntry(credit, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListCredits200Response> {
            return localVarFp.listCredits(xHumanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * Creates a new credit based on the input request data. 
     * @summary Create a new credit type
     * @param {CreateCreditRequest} createCreditRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCredit(createCreditRequest: CreateCreditRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCredit(createCreditRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new credit ledger entry for human. Requires a human id.
     * @summary Create a new credit ledger entry
     * @param {string} credit 
     * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single credit object
     * @param {string} credit 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getCredit(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getCredit(credit, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest credit ledger entry for a human. Requires a human id.
     * @param {string} credit 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getLatestCreditLedgerEntry(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getLatestCreditLedgerEntry(credit, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of credits
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public listCredits(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).listCredits(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DummyApi - axios parameter creator
 * @export
 */
export const DummyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Dummy endpoint for forcing generation objeects
         * @summary Dummy endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dummyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dummy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DummyApi - functional programming interface
 * @export
 */
export const DummyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DummyApiAxiosParamCreator(configuration)
    return {
        /**
         * Dummy endpoint for forcing generation objeects
         * @summary Dummy endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dummyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DummyGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dummyGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DummyApi.dummyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DummyApi - factory interface
 * @export
 */
export const DummyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DummyApiFp(configuration)
    return {
        /**
         * Dummy endpoint for forcing generation objeects
         * @summary Dummy endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dummyGet(options?: RawAxiosRequestConfig): AxiosPromise<DummyGet200Response> {
            return localVarFp.dummyGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DummyApi - object-oriented interface
 * @export
 * @class DummyApi
 * @extends {BaseAPI}
 */
export class DummyApi extends BaseAPI {
    /**
     * Dummy endpoint for forcing generation objeects
     * @summary Dummy endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DummyApi
     */
    public dummyGet(options?: RawAxiosRequestConfig) {
        return DummyApiFp(this.configuration).dummyGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InferenceApi - axios parameter creator
 * @export
 */
export const InferenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionRequest} chatCompletionRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCompletions: async (chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatCompletionRequest' is not null or undefined
            assertParamExists('chatCompletions', 'chatCompletionRequest', chatCompletionRequest)
            const localVarPath = `/v1/chat/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatCompletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InferenceApi - functional programming interface
 * @export
 */
export const InferenceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InferenceApiAxiosParamCreator(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionRequest} chatCompletionRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatCompletions(chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatCompletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatCompletions(chatCompletionRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InferenceApi.chatCompletions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InferenceApi - factory interface
 * @export
 */
export const InferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InferenceApiFp(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionRequest} chatCompletionRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCompletions(chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatCompletionResponse> {
            return localVarFp.chatCompletions(chatCompletionRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InferenceApi - object-oriented interface
 * @export
 * @class InferenceApi
 * @extends {BaseAPI}
 */
export class InferenceApi extends BaseAPI {
    /**
     * Given messages, generates LLM output text and optionally speech
     * @summary Chat Completions (+ Voice)
     * @param {ChatCompletionRequest} chatCompletionRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InferenceApi
     */
    public chatCompletions(chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return InferenceApiFp(this.configuration).chatCompletions(chatCompletionRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMApi - axios parameter creator
 * @export
 */
export const LLMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext: async (contextCreateRequest: ContextCreateRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextCreateRequest' is not null or undefined
            assertParamExists('createContext', 'contextCreateRequest', contextCreateRequest)
            const localVarPath = `/v1/llm/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContextMessage: async (context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('createContextMessage', 'context', context)
            // verify required parameter 'contextMessageCreateParams' is not null or undefined
            assertParamExists('createContextMessage', 'contextMessageCreateParams', contextMessageCreateParams)
            const localVarPath = `/v1/llm/context/{context}/message`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextMessageCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext: async (context: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getContext', 'context', context)
            const localVarPath = `/v1/llm/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextMessage: async (context: string, message: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getContextMessage', 'context', context)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('getContextMessage', 'message', message)
            const localVarPath = `/v1/llm/context/{context}/message/{message}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLLM: async (llm: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'llm' is not null or undefined
            assertParamExists('getLLM', 'llm', llm)
            const localVarPath = `/v1/llm/{llm}`
                .replace(`{${"llm"}}`, encodeURIComponent(String(llm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContextMessages: async (context: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('listContextMessages', 'context', context)
            const localVarPath = `/v1/llm/context/{context}/message/list`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLLMs: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/llm/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMApi - functional programming interface
 * @export
 */
export const LLMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContext(contextCreateRequest: ContextCreateRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(contextCreateRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContextMessage(context, contextMessageCreateParams, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContextMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContext(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(context, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextMessage(context: string, message: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextMessage(context, message, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContextMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLLM(llm: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LLM>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLLM(llm, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getLLM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContextMessages(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContextMessages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContextMessages(context, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.listContextMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLLMs(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLLMs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLLMs(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.listLLMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMApi - factory interface
 * @export
 */
export const LLMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMApiFp(configuration)
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext(contextCreateRequest: ContextCreateRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Context> {
            return localVarFp.createContext(contextCreateRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {
            return localVarFp.createContextMessage(context, contextMessageCreateParams, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Context> {
            return localVarFp.getContext(context, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextMessage(context: string, message: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {
            return localVarFp.getContextMessage(context, message, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLLM(llm: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<LLM> {
            return localVarFp.getLLM(llm, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContextMessages(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListContextMessages200Response> {
            return localVarFp.listContextMessages(context, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLLMs(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListLLMs200Response> {
            return localVarFp.listLLMs(xHumanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMApi - object-oriented interface
 * @export
 * @class LLMApi
 * @extends {BaseAPI}
 */
export class LLMApi extends BaseAPI {
    /**
     * Create a new Context with the given configuration. 
     * @summary Create a new Context.
     * @param {ContextCreateRequest} contextCreateRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public createContext(contextCreateRequest: ContextCreateRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).createContext(contextCreateRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ContextMessage with the given configuration. 
     * @summary Create a new ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {ContextMessageCreateParams} contextMessageCreateParams 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).createContextMessage(context, contextMessageCreateParams, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Context with the given identifier. 
     * @summary Retrieve a Context.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getContext(context: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getContext(context, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the ContextMessage with the given identifier. 
     * @summary Retrieve a ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {string} message The unique identifier of the ContextMessage.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getContextMessage(context: string, message: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getContextMessage(context, message, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of llms
     * @param {string} llm 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getLLM(llm: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getLLM(llm, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ContextMessages associated with the given Context. 
     * @summary List ContextMessages.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public listContextMessages(context: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).listContextMessages(context, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of llms
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public listLLMs(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).listLLMs(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona: async (createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonaRequest' is not null or undefined
            assertParamExists('createPersona', 'createPersonaRequest', createPersonaRequest)
            const localVarPath = `/v1/persona`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona: async (personaId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('deletePersona', 'personaId', personaId)
            const localVarPath = `/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersona: async (personaId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPersona', 'personaId', personaId)
            const localVarPath = `/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/persona/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona: async (personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('updatePersona', 'personaId', personaId)
            // verify required parameter 'updatePersonaRequest' is not null or undefined
            assertParamExists('updatePersona', 'updatePersonaRequest', updatePersonaRequest)
            const localVarPath = `/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersona(createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.createPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePersona200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(personaId, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.deletePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersona(personaId, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.getPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonas(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPersonas200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.listPersonas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(personaId, updatePersonaRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.updatePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona(createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.createPersona(createPersonaRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletePersona200Response> {
            return localVarFp.deletePersona(personaId, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getPersona(personaId, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPersonas200Response> {
            return localVarFp.listPersonas(xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.updatePersona(personaId, updatePersonaRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * 
     * @summary Create a persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public createPersona(createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).createPersona(createPersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public deletePersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).deletePersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public getPersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).getPersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of personas
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public listPersonas(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).listPersonas(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a persona
     * @param {string} personaId 
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).updatePersona(personaId, updatePersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealtimeApi - axios parameter creator
 * @export
 */
export const RealtimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endRealtimeSession: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('endRealtimeSession', 'session', session)
            const localVarPath = `/v1/realtime/{session}/end`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary Get a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSession: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('getRealtimeSession', 'session', session)
            const localVarPath = `/v1/realtime/{session}`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all ContextMessages associated with the given RealtimeSession. 
         * @summary Get a RealtimeSession messages.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSessionMessages: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('getRealtimeSessionMessages', 'session', session)
            const localVarPath = `/v1/realtime/{session}/messages`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the timeline of the RealtimeSession with the given identifier. 
         * @summary Get a RealtimeSession timeline.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSessionTimeline: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('getRealtimeSessionTimeline', 'session', session)
            const localVarPath = `/v1/realtime/{session}/timeline`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealtimeSessions: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/realtime/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRealtimeSession: async (startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startRealtimeSessionRequest' is not null or undefined
            assertParamExists('startRealtimeSession', 'startRealtimeSessionRequest', startRealtimeSessionRequest)
            const localVarPath = `/v1/realtime/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRealtimeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealtimeSession: async (session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('updateRealtimeSession', 'session', session)
            // verify required parameter 'realtimeSessionConfigUpdate' is not null or undefined
            assertParamExists('updateRealtimeSession', 'realtimeSessionConfigUpdate', realtimeSessionConfigUpdate)
            const localVarPath = `/v1/realtime/{session}/update`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionConfigUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealtimeApi - functional programming interface
 * @export
 */
export const RealtimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration)
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endRealtimeSession(session, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.endRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary Get a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSession(session, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all ContextMessages associated with the given RealtimeSession. 
         * @summary Get a RealtimeSession messages.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimeSessionMessages(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRealtimeSessionMessages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionMessages(session, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSessionMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the timeline of the RealtimeSession with the given identifier. 
         * @summary Get a RealtimeSession timeline.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimeSessionTimeline(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRealtimeSessionTimeline200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionTimeline(session, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSessionTimeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRealtimeSessions(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRealtimeSessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRealtimeSessions(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.listRealtimeSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSessionStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRealtimeSession(startRealtimeSessionRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.startRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.updateRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealtimeApi - factory interface
 * @export
 */
export const RealtimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealtimeApiFp(configuration)
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.endRealtimeSession(session, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary Get a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.getRealtimeSession(session, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all ContextMessages associated with the given RealtimeSession. 
         * @summary Get a RealtimeSession messages.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSessionMessages(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRealtimeSessionMessages200Response> {
            return localVarFp.getRealtimeSessionMessages(session, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the timeline of the RealtimeSession with the given identifier. 
         * @summary Get a RealtimeSession timeline.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSessionTimeline(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRealtimeSessionTimeline200Response> {
            return localVarFp.getRealtimeSessionTimeline(session, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealtimeSessions(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListRealtimeSessions200Response> {
            return localVarFp.listRealtimeSessions(xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSessionStartResponse> {
            return localVarFp.startRealtimeSession(startRealtimeSessionRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealtimeApi - object-oriented interface
 * @export
 * @class RealtimeApi
 * @extends {BaseAPI}
 */
export class RealtimeApi extends BaseAPI {
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public endRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).endRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public getRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).getRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all ContextMessages associated with the given RealtimeSession. 
     * @summary Get a RealtimeSession messages.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public getRealtimeSessionMessages(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).getRealtimeSessionMessages(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the timeline of the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession timeline.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public getRealtimeSessionTimeline(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).getRealtimeSessionTimeline(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Realtime Sessions. 
     * @summary List Realtime Sessions.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public listRealtimeSessions(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).listRealtimeSessions(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new RealtimeSession with the given configuration. 
     * @summary Start a new RealtimeSession.
     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).startRealtimeSession(startRealtimeSessionRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the RealtimeSession with the given identifier. 
     * @summary Update a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario: async (createScenarioRequest: CreateScenarioRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('createScenario', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/v1/scenario`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario: async (scenarioId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenario', 'scenarioId', scenarioId)
            const localVarPath = `/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenario: async (scenarioId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenario', 'scenarioId', scenarioId)
            const localVarPath = `/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenarios: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/scenario/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario: async (scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenario', 'scenarioId', scenarioId)
            // verify required parameter 'updateScenarioRequest' is not null or undefined
            assertParamExists('updateScenario', 'updateScenarioRequest', updateScenarioRequest)
            const localVarPath = `/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.createScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteScenario200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(scenarioId, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.deleteScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenario(scenarioId, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScenarios(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListScenarios200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScenarios(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.listScenarios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(scenarioId, updateScenarioRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.updateScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.createScenario(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteScenario200Response> {
            return localVarFp.deleteScenario(scenarioId, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.getScenario(scenarioId, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenarios(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListScenarios200Response> {
            return localVarFp.listScenarios(xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.updateScenario(scenarioId, updateScenarioRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Create a scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).createScenario(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of scenarios
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public listScenarios(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).listScenarios(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scenario
     * @param {string} scenarioId 
     * @param {UpdateScenarioRequest} updateScenarioRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenario(scenarioId, updateScenarioRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UsageTokenRequest} usageTokenRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageToken: async (usageTokenRequest: UsageTokenRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageTokenRequest' is not null or undefined
            assertParamExists('createUsageToken', 'usageTokenRequest', usageTokenRequest)
            const localVarPath = `/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usageTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageLimits: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/usage/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the usage limits of a human
         * @summary Update limits on a usage token
         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageToken: async (updateUsageLimitsRequest: UpdateUsageLimitsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUsageLimitsRequest' is not null or undefined
            assertParamExists('updateUsageToken', 'updateUsageLimitsRequest', updateUsageLimitsRequest)
            const localVarPath = `/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageLimitsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UsageTokenRequest} usageTokenRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageToken(usageTokenRequest: UsageTokenRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUsageToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageToken(usageTokenRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.createUsageToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageLimits(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageLimitsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageLimits(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.getUsageLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the usage limits of a human
         * @summary Update limits on a usage token
         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageToken(updateUsageLimitsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.updateUsageToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UsageTokenRequest} usageTokenRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageToken(usageTokenRequest: UsageTokenRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUsageToken200Response> {
            return localVarFp.createUsageToken(usageTokenRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageLimits(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UsageLimitsInner>> {
            return localVarFp.getUsageLimits(xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the usage limits of a human
         * @summary Update limits on a usage token
         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {UsageTokenRequest} usageTokenRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public createUsageToken(usageTokenRequest: UsageTokenRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).createUsageToken(usageTokenRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsageLimits(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).getUsageLimits(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the usage limits of a human
     * @summary Update limits on a usage token
     * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceApi - axios parameter creator
 * @export
 */
export const VoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneVoice: async (name: string, language: string, file: File, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('cloneVoice', 'name', name)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('cloneVoice', 'language', language)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('cloneVoice', 'file', file)
            const localVarPath = `/v1/voice/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('deleteVoice', 'voiceId', voiceId)
            const localVarPath = `/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateVoice: async (generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateVoiceRequest' is not null or undefined
            assertParamExists('generateVoice', 'generateVoiceRequest', generateVoiceRequest)
            const localVarPath = `/v1/voice/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateVoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('getVoice', 'voiceId', voiceId)
            const localVarPath = `/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoices: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/voice/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xHumanId != null) {
                localVarHeaderParameter['x-human-id'] = String(xHumanId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoice: async (voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('updateVoice', 'voiceId', voiceId)
            // verify required parameter 'updateVoiceRequest' is not null or undefined
            assertParamExists('updateVoice', 'updateVoiceRequest', updateVoiceRequest)
            const localVarPath = `/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceApi - functional programming interface
 * @export
 */
export const VoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneVoice(name: string, language: string, file: File, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneVoice(name, language, file, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.cloneVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoice(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.deleteVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateVoice(generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateVoice(generateVoiceRequest, xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.generateVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoice(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.getVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoices(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVoices(xHumanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.listVoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoice(voiceId, updateVoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.updateVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceApi - factory interface
 * @export
 */
export const VoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceApiFp(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneVoice(name: string, language: string, file: File, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.cloneVoice(name, language, file, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVoice200Response> {
            return localVarFp.deleteVoice(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateVoice(generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.generateVoice(generateVoiceRequest, xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.getVoice(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoices(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListVoices200Response> {
            return localVarFp.listVoices(xHumanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceApi - object-oriented interface
 * @export
 * @class VoiceApi
 * @extends {BaseAPI}
 */
export class VoiceApi extends BaseAPI {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public cloneVoice(name: string, language: string, file: File, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).cloneVoice(name, language, file, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public deleteVoice(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).deleteVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {GenerateVoiceRequest} generateVoiceRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public generateVoice(generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).generateVoice(generateVoiceRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public getVoice(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).getVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of voices
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public listVoices(xHumanId?: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).listVoices(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {UpdateVoiceRequest} updateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



