/* tslint:disable */
/* eslint-disable */
/**
 * Session API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiV1SessionListGet200Response
 */
export interface ApiV1SessionListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionListGet200Response
     */
    'total_count': number;
    /**
     * The array of sessions.
     * @type {Array<Session>}
     * @memberof ApiV1SessionListGet200Response
     */
    'values': Array<Session>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdMessagesGet200Response
 */
export interface ApiV1SessionSessionIdMessagesGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'total_count': number;
    /**
     * The array of session timeline items.
     * @type {Array<SessionMessage>}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'values': Array<SessionMessage>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdTimelineGet200Response
 */
export interface ApiV1SessionSessionIdTimelineGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'next_page'?: string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'total_count'?: number;
    /**
     * The array of session timeline items.
     * @type {Array<SessionTimelineItem>}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'values'?: Array<SessionTimelineItem>;
}
/**
 * 
 * @export
 * @interface ChatCompletionRequest
 */
export interface ChatCompletionRequest {
    /**
     * Chat context
     * @type {Array<ChatCompletionRequestMessage>}
     * @memberof ChatCompletionRequest
     */
    'messages': Array<ChatCompletionRequestMessage>;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionRequest
     */
    'model': string;
    /**
     * 
     * @type {object}
     * @memberof ChatCompletionRequest
     */
    'metadata'?: object;
    /**
     * 
     * @type {ChatCompletionRequestGabber}
     * @memberof ChatCompletionRequest
     */
    'gabber'?: ChatCompletionRequestGabber;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. 
     * @type {boolean}
     * @memberof ChatCompletionRequest
     */
    'stream'?: boolean;
    /**
     * Temperature for sampling from the model. Higher values mean more randomness. 
     * @type {number}
     * @memberof ChatCompletionRequest
     */
    'temperature'?: number;
    /**
     * Maximum number of tokens to generate. Requests can be up to 4096 tokens. 
     * @type {number}
     * @memberof ChatCompletionRequest
     */
    'max_tokens'?: number;
}
/**
 * 
 * @export
 * @interface ChatCompletionRequestGabber
 */
export interface ChatCompletionRequestGabber {
    /**
     * Gabber voice id
     * @type {string}
     * @memberof ChatCompletionRequestGabber
     */
    'voice'?: string;
}
/**
 * 
 * @export
 * @interface ChatCompletionRequestMessage
 */
export interface ChatCompletionRequestMessage {
    /**
     * 
     * @type {ChatCompletionRequestMessageContent}
     * @memberof ChatCompletionRequestMessage
     */
    'content': ChatCompletionRequestMessageContent;
    /**
     * The role of the messages author.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    'role': ChatCompletionRequestMessageRoleEnum;
}

export const ChatCompletionRequestMessageRoleEnum = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type ChatCompletionRequestMessageRoleEnum = typeof ChatCompletionRequestMessageRoleEnum[keyof typeof ChatCompletionRequestMessageRoleEnum];

/**
 * @type ChatCompletionRequestMessageContent
 * The contents of the message.
 * @export
 */
export type ChatCompletionRequestMessageContent = Array<ChatCompletionRequestUserMessageContentPart> | string;

/**
 * 
 * @export
 * @interface ChatCompletionRequestMessageContentPartAudio
 */
export interface ChatCompletionRequestMessageContentPartAudio {
    /**
     * Audio content type.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudio
     */
    'type': ChatCompletionRequestMessageContentPartAudioTypeEnum;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartAudioInputAudio}
     * @memberof ChatCompletionRequestMessageContentPartAudio
     */
    'input_audio': ChatCompletionRequestMessageContentPartAudioInputAudio;
}

export const ChatCompletionRequestMessageContentPartAudioTypeEnum = {
    InputAudio: 'input_audio'
} as const;

export type ChatCompletionRequestMessageContentPartAudioTypeEnum = typeof ChatCompletionRequestMessageContentPartAudioTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletionRequestMessageContentPartAudioInputAudio
 */
export interface ChatCompletionRequestMessageContentPartAudioInputAudio {
    /**
     * Base64 encoded audio data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio
     */
    'data': string;
    /**
     * The format of the audio data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio
     */
    'format': ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum;
}

export const ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = {
    Wav: 'wav',
    Mp3: 'mp3',
    Ogg: 'ogg'
} as const;

export type ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum];

/**
 * Text content
 * @export
 * @interface ChatCompletionRequestMessageContentPartText
 */
export interface ChatCompletionRequestMessageContentPartText {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    'type': ChatCompletionRequestMessageContentPartTextTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    'text': string;
}

export const ChatCompletionRequestMessageContentPartTextTypeEnum = {
    Text: 'text'
} as const;

export type ChatCompletionRequestMessageContentPartTextTypeEnum = typeof ChatCompletionRequestMessageContentPartTextTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartTextTypeEnum];

/**
 * @type ChatCompletionRequestUserMessageContentPart
 * @export
 */
export type ChatCompletionRequestUserMessageContentPart = ChatCompletionRequestMessageContentPartAudio | ChatCompletionRequestMessageContentPartText;

/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape. 
 * @export
 * @interface ChatCompletionResponse
 */
export interface ChatCompletionResponse {
    /**
     * A list of chat completion choices.
     * @type {Array<ChatCompletionResponseChoicesInner>}
     * @memberof ChatCompletionResponse
     */
    'choices': Array<ChatCompletionResponseChoicesInner>;
    /**
     * The model used for completion.
     * @type {string}
     * @memberof ChatCompletionResponse
     */
    'model': string;
    /**
     * 
     * @type {ChatCompletionResponseGabber}
     * @memberof ChatCompletionResponse
     */
    'gabber'?: ChatCompletionResponseGabber;
}
/**
 * 
 * @export
 * @interface ChatCompletionResponseChoicesInner
 */
export interface ChatCompletionResponseChoicesInner {
    /**
     * 
     * @type {ChatCompletionResponseMessage}
     * @memberof ChatCompletionResponseChoicesInner
     */
    'message': ChatCompletionResponseMessage;
}
/**
 * 
 * @export
 * @interface ChatCompletionResponseGabber
 */
export interface ChatCompletionResponseGabber {
    /**
     * 
     * @type {Array<ChatCompletionResponseGabberMessageDataInner>}
     * @memberof ChatCompletionResponseGabber
     */
    'message_data'?: Array<ChatCompletionResponseGabberMessageDataInner>;
}
/**
 * 
 * @export
 * @interface ChatCompletionResponseGabberMessageDataInner
 */
export interface ChatCompletionResponseGabberMessageDataInner {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionResponseGabberMessageDataInner
     */
    'message_index': number;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionResponseGabberMessageDataInner
     */
    'content_index': number;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionResponseGabberMessageDataInner
     */
    'type': ChatCompletionResponseGabberMessageDataInnerTypeEnum;
    /**
     * 
     * @type {ChatCompletionResponseGabberMessageDataInnerData}
     * @memberof ChatCompletionResponseGabberMessageDataInner
     */
    'data': ChatCompletionResponseGabberMessageDataInnerData;
}

export const ChatCompletionResponseGabberMessageDataInnerTypeEnum = {
    AudioTranscript: 'audio_transcript'
} as const;

export type ChatCompletionResponseGabberMessageDataInnerTypeEnum = typeof ChatCompletionResponseGabberMessageDataInnerTypeEnum[keyof typeof ChatCompletionResponseGabberMessageDataInnerTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletionResponseGabberMessageDataInnerData
 */
export interface ChatCompletionResponseGabberMessageDataInnerData {
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionResponseGabberMessageDataInnerData
     */
    'transcript'?: string;
}
/**
 * A chat completion message generated by the model.
 * @export
 * @interface ChatCompletionResponseMessage
 */
export interface ChatCompletionResponseMessage {
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'content': string;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'refusal': string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaGabber}
     * @memberof ChatCompletionResponseMessage
     */
    'gabber'?: ChatCompletionStreamResponseDeltaGabber;
}

export const ChatCompletionResponseMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ChatCompletionResponseMessageRoleEnum = typeof ChatCompletionResponseMessageRoleEnum[keyof typeof ChatCompletionResponseMessageRoleEnum];

/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 * @export
 * @interface ChatCompletionStreamResponse
 */
export interface ChatCompletionStreamResponse {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     * @type {string}
     * @memberof ChatCompletionStreamResponse
     */
    'id': string;
    /**
     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
     * @type {Array<ChatCompletionStreamResponseChoicesInner>}
     * @memberof ChatCompletionStreamResponse
     */
    'choices': Array<ChatCompletionStreamResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     * @type {number}
     * @memberof ChatCompletionStreamResponse
     */
    'created': number;
    /**
     * The model to generate the completion.
     * @type {string}
     * @memberof ChatCompletionStreamResponse
     */
    'model': string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     * @type {string}
     * @memberof ChatCompletionStreamResponse
     */
    'object': ChatCompletionStreamResponseObjectEnum;
    /**
     * 
     * @type {ChatCompletionStreamResponseGabber}
     * @memberof ChatCompletionStreamResponse
     */
    'gabber'?: ChatCompletionStreamResponseGabber;
}

export const ChatCompletionStreamResponseObjectEnum = {
    ChatCompletionChunk: 'chat.completion.chunk'
} as const;

export type ChatCompletionStreamResponseObjectEnum = typeof ChatCompletionStreamResponseObjectEnum[keyof typeof ChatCompletionStreamResponseObjectEnum];

/**
 * 
 * @export
 * @interface ChatCompletionStreamResponseChoicesInner
 */
export interface ChatCompletionStreamResponseChoicesInner {
    /**
     * 
     * @type {ChatCompletionStreamResponseDelta}
     * @memberof ChatCompletionStreamResponseChoicesInner
     */
    'delta': ChatCompletionStreamResponseDelta;
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof ChatCompletionStreamResponseChoicesInner
     */
    'finish_reason': ChatCompletionStreamResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof ChatCompletionStreamResponseChoicesInner
     */
    'index': number;
}

export const ChatCompletionStreamResponseChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ToolCalls: 'tool_calls',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
} as const;

export type ChatCompletionStreamResponseChoicesInnerFinishReasonEnum = typeof ChatCompletionStreamResponseChoicesInnerFinishReasonEnum[keyof typeof ChatCompletionStreamResponseChoicesInnerFinishReasonEnum];

/**
 * A chat completion delta generated by streamed model responses.
 * @export
 * @interface ChatCompletionStreamResponseDelta
 */
export interface ChatCompletionStreamResponseDelta {
    /**
     * The contents of the chunk message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'content'?: string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'role'?: ChatCompletionStreamResponseDeltaRoleEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'refusal'?: string;
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaGabber}
     * @memberof ChatCompletionStreamResponseDelta
     */
    'gabber'?: ChatCompletionStreamResponseDeltaGabber;
}

export const ChatCompletionStreamResponseDeltaRoleEnum = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant'
} as const;

export type ChatCompletionStreamResponseDeltaRoleEnum = typeof ChatCompletionStreamResponseDeltaRoleEnum[keyof typeof ChatCompletionStreamResponseDeltaRoleEnum];

/**
 * If the audio output modality is requested, this object contains data
 * @export
 * @interface ChatCompletionStreamResponseDeltaGabber
 */
export interface ChatCompletionStreamResponseDeltaGabber {
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaGabberVoice}
     * @memberof ChatCompletionStreamResponseDeltaGabber
     */
    'voice'?: ChatCompletionStreamResponseDeltaGabberVoice;
}
/**
 * 
 * @export
 * @interface ChatCompletionStreamResponseDeltaGabberVoice
 */
export interface ChatCompletionStreamResponseDeltaGabberVoice {
    /**
     * This will be the URL to the audio file
     * @type {string}
     * @memberof ChatCompletionStreamResponseDeltaGabberVoice
     */
    'audio_url': string;
    /**
     * The Unix timestamp (in seconds) when the audio file expires
     * @type {number}
     * @memberof ChatCompletionStreamResponseDeltaGabberVoice
     */
    'expires_at': number;
}
/**
 * Gabber-specific fields
 * @export
 * @interface ChatCompletionStreamResponseGabber
 */
export interface ChatCompletionStreamResponseGabber {
    /**
     * Gabber usage for this request
     * @type {Usage}
     * @memberof ChatCompletionStreamResponseGabber
     */
    'usage'?: Usage;
    /**
     * 
     * @type {Array<ChatCompletionStreamResponseGabberMessageDataInner>}
     * @memberof ChatCompletionStreamResponseGabber
     */
    'message_data'?: Array<ChatCompletionStreamResponseGabberMessageDataInner>;
}
/**
 * 
 * @export
 * @interface ChatCompletionStreamResponseGabberMessageDataInner
 */
export interface ChatCompletionStreamResponseGabberMessageDataInner {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionStreamResponseGabberMessageDataInner
     */
    'message_index': number;
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionStreamResponseGabberMessageDataInner
     */
    'content_index': number;
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionStreamResponseGabberMessageDataInner
     */
    'type': ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum;
    /**
     * 
     * @type {ChatCompletionStreamResponseGabberMessageDataInnerData}
     * @memberof ChatCompletionStreamResponseGabberMessageDataInner
     */
    'data': ChatCompletionStreamResponseGabberMessageDataInnerData;
}

export const ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum = {
    AudioTranscript: 'audio_transcript'
} as const;

export type ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum = typeof ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum[keyof typeof ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum];

/**
 * 
 * @export
 * @interface ChatCompletionStreamResponseGabberMessageDataInnerData
 */
export interface ChatCompletionStreamResponseGabberMessageDataInnerData {
    /**
     * 
     * @type {string}
     * @memberof ChatCompletionStreamResponseGabberMessageDataInnerData
     */
    'transcript': string;
}
/**
 * 
 * @export
 * @interface CloneVoice200Response
 */
export interface CloneVoice200Response {
    /**
     * 
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'message': string;
    /**
     * Name of the cloned voice
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'name': string;
    /**
     * Language of the cloned voice
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'language': string;
    /**
     * Unique identifier of the cloned voice
     * @type {string}
     * @memberof CloneVoice200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'human'?: string;
}
/**
 * 
 * @export
 * @interface ContextCreateRequest
 */
export interface ContextCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequest
     */
    'persona'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequest
     */
    'scenario'?: string;
    /**
     * 
     * @type {Array<ContextCreateRequestMessagesInner>}
     * @memberof ContextCreateRequest
     */
    'messages'?: Array<ContextCreateRequestMessagesInner>;
}
/**
 * 
 * @export
 * @interface ContextCreateRequestMessagesInner
 */
export interface ContextCreateRequestMessagesInner {
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequestMessagesInner
     */
    'role': ContextCreateRequestMessagesInnerRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextCreateRequestMessagesInner
     */
    'content': string;
}

export const ContextCreateRequestMessagesInnerRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextCreateRequestMessagesInnerRoleEnum = typeof ContextCreateRequestMessagesInnerRoleEnum[keyof typeof ContextCreateRequestMessagesInnerRoleEnum];

/**
 * 
 * @export
 * @interface ContextMessage
 */
export interface ContextMessage {
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'speaking_ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'role': ContextMessageRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessage
     */
    'created_at': string;
}

export const ContextMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextMessageRoleEnum = typeof ContextMessageRoleEnum[keyof typeof ContextMessageRoleEnum];

/**
 * 
 * @export
 * @interface ContextMessageCreateParams
 */
export interface ContextMessageCreateParams {
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'speaking_ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'role': ContextMessageCreateParamsRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextMessageCreateParams
     */
    'content': string;
}

export const ContextMessageCreateParamsRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ContextMessageCreateParamsRoleEnum = typeof ContextMessageCreateParamsRoleEnum[keyof typeof ContextMessageCreateParamsRoleEnum];

/**
 * 
 * @export
 * @interface CreateCreditLedgerEntryRequest
 */
export interface CreateCreditLedgerEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * The name of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof CreateCreditRequest
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreatePersonaRequest
 */
export interface CreatePersonaRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'gender'?: CreatePersonaRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'voice': string;
}

export const CreatePersonaRequestGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type CreatePersonaRequestGenderEnum = typeof CreatePersonaRequestGenderEnum[keyof typeof CreatePersonaRequestGenderEnum];

/**
 * 
 * @export
 * @interface CreateScenarioRequest
 */
export interface CreateScenarioRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof CreateScenarioRequest
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface CreateUsageToken200Response
 */
export interface CreateUsageToken200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateUsageToken200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * The date and time the credit was created.
     * @type {string}
     * @memberof Credit
     */
    'created_at': string;
    /**
     * The unique identifier of the credit.
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * The project the credit belongs to.
     * @type {string}
     * @memberof Credit
     */
    'project': string;
    /**
     * The name of the credit.
     * @type {string}
     * @memberof Credit
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof Credit
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof Credit
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreditLedgerEntry
 */
export interface CreditLedgerEntry {
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'credit': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'human': string;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface DeletePersona200Response
 */
export interface DeletePersona200Response {
    /**
     * 
     * @type {string}
     * @memberof DeletePersona200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteScenario200Response
 */
export interface DeleteScenario200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteScenario200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteVoice200Response
 */
export interface DeleteVoice200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteVoice200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GenerateVoiceRequest
 */
export interface GenerateVoiceRequest {
    /**
     * Text to synthesize into voice
     * @type {string}
     * @memberof GenerateVoiceRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateVoiceRequest
     */
    'voice_id': string;
    /**
     * Whether to moderate the text.
     * @type {boolean}
     * @memberof GenerateVoiceRequest
     */
    'moderation'?: boolean;
}
/**
 * 
 * @export
 * @interface HistoryMessage
 */
export interface HistoryMessage {
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'role': HistoryMessageRoleEnum;
}

export const HistoryMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type HistoryMessageRoleEnum = typeof HistoryMessageRoleEnum[keyof typeof HistoryMessageRoleEnum];

/**
 * @type InlineObject
 * @export
 */
export type InlineObject = InlineObjectOneOf | InlineObjectOneOf1 | InlineObjectOneOf2;

/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Error message.
     * @type {string}
     * @memberof InlineObject1
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface InlineObjectOneOf
 */
export interface InlineObjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf
     */
    'type'?: InlineObjectOneOfTypeEnum;
}

export const InlineObjectOneOfTypeEnum = {
    UsageLimitExceeded: 'usage_limit_exceeded'
} as const;

export type InlineObjectOneOfTypeEnum = typeof InlineObjectOneOfTypeEnum[keyof typeof InlineObjectOneOfTypeEnum];

/**
 * 
 * @export
 * @interface InlineObjectOneOf1
 */
export interface InlineObjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf1
     */
    'type'?: InlineObjectOneOf1TypeEnum;
}

export const InlineObjectOneOf1TypeEnum = {
    ProjectDisabled: 'project_disabled'
} as const;

export type InlineObjectOneOf1TypeEnum = typeof InlineObjectOneOf1TypeEnum[keyof typeof InlineObjectOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface InlineObjectOneOf2
 */
export interface InlineObjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf2
     */
    'type'?: InlineObjectOneOf2TypeEnum;
}

export const InlineObjectOneOf2TypeEnum = {
    ModerationError: 'moderation_error'
} as const;

export type InlineObjectOneOf2TypeEnum = typeof InlineObjectOneOf2TypeEnum[keyof typeof InlineObjectOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface LLM
 */
export interface LLM {
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof LLM
     */
    'compliance': boolean;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ListContextMessages200Response
 */
export interface ListContextMessages200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof ListContextMessages200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof ListContextMessages200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<ContextMessage>}
     * @memberof ListContextMessages200Response
     */
    'values': Array<ContextMessage>;
}
/**
 * 
 * @export
 * @interface ListCredits200Response
 */
export interface ListCredits200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListCredits200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListCredits200Response
     */
    'total_count': number;
    /**
     * The array of credits.
     * @type {Array<Credit>}
     * @memberof ListCredits200Response
     */
    'values': Array<Credit>;
}
/**
 * 
 * @export
 * @interface ListLLMs200Response
 */
export interface ListLLMs200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListLLMs200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListLLMs200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<LLM>}
     * @memberof ListLLMs200Response
     */
    'values': Array<LLM>;
}
/**
 * 
 * @export
 * @interface ListPersonas200Response
 */
export interface ListPersonas200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListPersonas200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListPersonas200Response
     */
    'total_count': number;
    /**
     * The array of personas.
     * @type {Array<Persona>}
     * @memberof ListPersonas200Response
     */
    'values': Array<Persona>;
}
/**
 * 
 * @export
 * @interface ListRealtimeSessions200Response
 */
export interface ListRealtimeSessions200Response {
    /**
     * The URL to the next page of items.
     * @type {string}
     * @memberof ListRealtimeSessions200Response
     */
    'next_page'?: string;
    /**
     * The total number of items.
     * @type {number}
     * @memberof ListRealtimeSessions200Response
     */
    'total_count': number;
    /**
     * The list of items.
     * @type {Array<RealtimeSession>}
     * @memberof ListRealtimeSessions200Response
     */
    'values': Array<RealtimeSession>;
}
/**
 * 
 * @export
 * @interface ListScenarios200Response
 */
export interface ListScenarios200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListScenarios200Response
     */
    'next_page'?: string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListScenarios200Response
     */
    'total_count': number;
    /**
     * The array of scenarios.
     * @type {Array<Scenario>}
     * @memberof ListScenarios200Response
     */
    'values': Array<Scenario>;
}
/**
 * 
 * @export
 * @interface ListVoices200Response
 */
export interface ListVoices200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ListVoices200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ListVoices200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<Voice>}
     * @memberof ListVoices200Response
     */
    'values': Array<Voice>;
}
/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {Array<PersonaTagsInner>}
     * @memberof Persona
     */
    'tags'?: Array<PersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'voice': string;
}

export const PersonaGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type PersonaGenderEnum = typeof PersonaGenderEnum[keyof typeof PersonaGenderEnum];

/**
 * 
 * @export
 * @interface PersonaTagsInner
 */
export interface PersonaTagsInner {
    /**
     * 
     * @type {string}
     * @memberof PersonaTagsInner
     */
    'human_name': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaTagsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface RealtimeSession
 */
export interface RealtimeSession {
    /**
     * The unique identifier of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSession
     */
    'id': string;
    /**
     * The current state of the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSession
     */
    'state': RealtimeSessionStateEnum;
    /**
     * The time the RealtimeSession was created.
     * @type {string}
     * @memberof RealtimeSession
     */
    'created_at': string;
    /**
     * The time the RealtimeSession ended.
     * @type {string}
     * @memberof RealtimeSession
     */
    'ended_at'?: string;
    /**
     * The project identifier.
     * @type {string}
     * @memberof RealtimeSession
     */
    'project': string;
    /**
     * The human identifier.
     * @type {string}
     * @memberof RealtimeSession
     */
    'human'?: string;
    /**
     * Whether the session is simulated or not.
     * @type {boolean}
     * @memberof RealtimeSession
     */
    'simulated': boolean;
    /**
     * 
     * @type {RealtimeSessionConfig}
     * @memberof RealtimeSession
     */
    'config': RealtimeSessionConfig;
}

export const RealtimeSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type RealtimeSessionStateEnum = typeof RealtimeSessionStateEnum[keyof typeof RealtimeSessionStateEnum];

/**
 * 
 * @export
 * @interface RealtimeSessionConfig
 */
export interface RealtimeSessionConfig {
    /**
     * 
     * @type {RealtimeSessionGeneralConfig}
     * @memberof RealtimeSessionConfig
     */
    'general': RealtimeSessionGeneralConfig;
    /**
     * 
     * @type {RealtimeSessionInputConfig}
     * @memberof RealtimeSessionConfig
     */
    'input': RealtimeSessionInputConfig;
    /**
     * 
     * @type {RealtimeSessionGenerativeConfig}
     * @memberof RealtimeSessionConfig
     */
    'generative': RealtimeSessionGenerativeConfig;
    /**
     * 
     * @type {RealtimeSessionOutputConfig}
     * @memberof RealtimeSessionConfig
     */
    'output': RealtimeSessionOutputConfig;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigCreate
 */
export interface RealtimeSessionConfigCreate {
    /**
     * 
     * @type {RealtimeSessionGeneralConfig}
     * @memberof RealtimeSessionConfigCreate
     */
    'general': RealtimeSessionGeneralConfig;
    /**
     * 
     * @type {RealtimeSessionInputConfig}
     * @memberof RealtimeSessionConfigCreate
     */
    'input': RealtimeSessionInputConfig;
    /**
     * 
     * @type {RealtimeSessionGenerativeConfigCreate}
     * @memberof RealtimeSessionConfigCreate
     */
    'generative': RealtimeSessionGenerativeConfigCreate;
    /**
     * 
     * @type {RealtimeSessionOutputConfig}
     * @memberof RealtimeSessionConfigCreate
     */
    'output': RealtimeSessionOutputConfig;
}
/**
 * 
 * @export
 * @interface RealtimeSessionConfigUpdate
 */
export interface RealtimeSessionConfigUpdate {
    /**
     * 
     * @type {RealtimeSessionGeneralConfig}
     * @memberof RealtimeSessionConfigUpdate
     */
    'general'?: RealtimeSessionGeneralConfig;
    /**
     * 
     * @type {RealtimeSessionInputConfig}
     * @memberof RealtimeSessionConfigUpdate
     */
    'input'?: RealtimeSessionInputConfig;
    /**
     * 
     * @type {RealtimeSessionGenerativeConfigUpdate}
     * @memberof RealtimeSessionConfigUpdate
     */
    'generative'?: RealtimeSessionGenerativeConfigUpdate;
    /**
     * 
     * @type {RealtimeSessionOutputConfig}
     * @memberof RealtimeSessionConfigUpdate
     */
    'output'?: RealtimeSessionOutputConfig;
}
/**
 * 
 * @export
 * @interface RealtimeSessionGeneralConfig
 */
export interface RealtimeSessionGeneralConfig {
    /**
     * The time limit in seconds for the RealtimeSession.
     * @type {number}
     * @memberof RealtimeSessionGeneralConfig
     */
    'time_limit_s'?: number;
    /**
     * Whether to save messages in the RealtimeSession. These will be saved to the context provided in the generative config. If no context is provided, a new context will be created when the session starts. 
     * @type {boolean}
     * @memberof RealtimeSessionGeneralConfig
     */
    'save_messages'?: boolean;
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionGenerativeConfig
 */
export interface RealtimeSessionGenerativeConfig {
    /**
     * 
     * @type {LLM}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'llm': LLM;
    /**
     * 
     * @type {Voice}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'voice_override'?: Voice;
    /**
     * 
     * @type {Persona}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'persona'?: Persona;
    /**
     * 
     * @type {Scenario}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'scenario'?: Scenario;
    /**
     * 
     * @type {Context}
     * @memberof RealtimeSessionGenerativeConfig
     */
    'context': Context;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof RealtimeSessionGenerativeConfig
     */
    '_extra'?: { [key: string]: any; };
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionGenerativeConfigCreate
 */
export interface RealtimeSessionGenerativeConfigCreate {
    /**
     * The LLM to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'llm': string;
    /**
     * The voice to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'voice_override'?: string;
    /**
     * The persona to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'persona'?: string;
    /**
     * The scenario to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'scenario'?: string;
    /**
     * The context to use for the RealtimeSession. If unspecified, a new context will be created.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    'context'?: string;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof RealtimeSessionGenerativeConfigCreate
     */
    '_extra'?: { [key: string]: any; };
}
/**
 * Configuration for the generative AI in the RealtimeSession.
 * @export
 * @interface RealtimeSessionGenerativeConfigUpdate
 */
export interface RealtimeSessionGenerativeConfigUpdate {
    /**
     * The LLM to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'llm'?: string;
    /**
     * The voice to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'voice_override'?: string;
    /**
     * The persona to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'persona'?: string;
    /**
     * The scenario to use for the RealtimeSession.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'scenario'?: string;
    /**
     * The context to use for the RealtimeSession. If unspecified, a new context will be created.
     * @type {string}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    'context'?: string;
    /**
     * Extra configuration for the generative AI. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof RealtimeSessionGenerativeConfigUpdate
     */
    '_extra'?: { [key: string]: any; };
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionInputConfig
 */
export interface RealtimeSessionInputConfig {
    /**
     * Whether the system allows interruption during speech.
     * @type {boolean}
     * @memberof RealtimeSessionInputConfig
     */
    'interruptable'?: boolean;
    /**
     * Whether the AI should continue listening while speaking. If true, the AI will produce another response immediately after the first one. This is only relevant if interruptable is false. 
     * @type {boolean}
     * @memberof RealtimeSessionInputConfig
     */
    'parallel_listening'?: boolean;
}
/**
 * Configuration for the output of the RealtimeSession.
 * @export
 * @interface RealtimeSessionOutputConfig
 */
export interface RealtimeSessionOutputConfig {
    /**
     * Whether to stream AI spoken transcript or send full transcript when it\'s available all at once.
     * @type {boolean}
     * @memberof RealtimeSessionOutputConfig
     */
    'stream_transcript'?: boolean;
    /**
     * Whether to enable speech synthesis for the RealtimeSession.
     * @type {boolean}
     * @memberof RealtimeSessionOutputConfig
     */
    'speech_synthesis_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface RealtimeSessionStartResponse
 */
export interface RealtimeSessionStartResponse {
    /**
     * 
     * @type {RealtimeSession}
     * @memberof RealtimeSessionStartResponse
     */
    'session': RealtimeSession;
    /**
     * 
     * @type {RealtimeSessionStartResponseConnectionDetails}
     * @memberof RealtimeSessionStartResponse
     */
    'connection_details': RealtimeSessionStartResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface RealtimeSessionStartResponseConnectionDetails
 */
export interface RealtimeSessionStartResponseConnectionDetails {
    /**
     * The URL to connect to the RealtimeSession
     * @type {string}
     * @memberof RealtimeSessionStartResponseConnectionDetails
     */
    'url': string;
    /**
     * The token to use to connect to the RealtimeSession
     * @type {string}
     * @memberof RealtimeSessionStartResponseConnectionDetails
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof Session
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'state': SessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'time_limit_s': number;
}

export const SessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type SessionStateEnum = typeof SessionStateEnum[keyof typeof SessionStateEnum];

/**
 * 
 * @export
 * @interface SessionMessage
 */
export interface SessionMessage {
    /**
     * 
     * @type {boolean}
     * @memberof SessionMessage
     */
    'agent': boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'import_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'media'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'session': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'speaking_ended_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'text'?: string;
}
/**
 * @type SessionStartRequest
 * @export
 */
export type SessionStartRequest = SessionStartRequestOneOf | SessionStartRequestOneOf1;

/**
 * 
 * @export
 * @interface SessionStartRequestOneOf
 */
export interface SessionStartRequestOneOf {
    /**
     * 
     * @type {Array<HistoryMessage>}
     * @memberof SessionStartRequestOneOf
     */
    'history'?: Array<HistoryMessage>;
    /**
     * 
     * @type {number}
     * @memberof SessionStartRequestOneOf
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof SessionStartRequestOneOf
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof SessionStartRequestOneOf
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface SessionStartRequestOneOf1
 */
export interface SessionStartRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof SessionStartRequestOneOf1
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'scenario'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartRequestOneOf1
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof SessionStartRequestOneOf1
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof SessionStartRequestOneOf1
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface SessionStartResponse
 */
export interface SessionStartResponse {
    /**
     * 
     * @type {Session}
     * @memberof SessionStartResponse
     */
    'session': Session;
    /**
     * 
     * @type {Persona}
     * @memberof SessionStartResponse
     */
    'persona'?: Persona;
    /**
     * 
     * @type {Scenario}
     * @memberof SessionStartResponse
     */
    'scenario'?: Scenario;
    /**
     * 
     * @type {SessionStartResponseConnectionDetails}
     * @memberof SessionStartResponse
     */
    'connection_details': SessionStartResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface SessionStartResponseConnectionDetails
 */
export interface SessionStartResponseConnectionDetails {
    /**
     * 
     * @type {string}
     * @memberof SessionStartResponseConnectionDetails
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionStartResponseConnectionDetails
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SessionTimelineItem
 */
export interface SessionTimelineItem {
    /**
     * 
     * @type {number}
     * @memberof SessionTimelineItem
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionTimelineItem
     */
    'type'?: SessionTimelineItemTypeEnum;
}

export const SessionTimelineItemTypeEnum = {
    Silence: 'silence',
    Agent: 'agent',
    User: 'user'
} as const;

export type SessionTimelineItemTypeEnum = typeof SessionTimelineItemTypeEnum[keyof typeof SessionTimelineItemTypeEnum];

/**
 * 
 * @export
 * @interface StartRealtimeSessionRequest
 */
export interface StartRealtimeSessionRequest {
    /**
     * Whether the session is simulated.
     * @type {boolean}
     * @memberof StartRealtimeSessionRequest
     */
    'simulated'?: boolean;
    /**
     * 
     * @type {RealtimeSessionConfigCreate}
     * @memberof StartRealtimeSessionRequest
     */
    'config': RealtimeSessionConfigCreate;
}
/**
 * 
 * @export
 * @interface UpdatePersonaRequest
 */
export interface UpdatePersonaRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'gender'?: UpdatePersonaRequestGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'voice'?: string;
}

export const UpdatePersonaRequestGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type UpdatePersonaRequestGenderEnum = typeof UpdatePersonaRequestGenderEnum[keyof typeof UpdatePersonaRequestGenderEnum];

/**
 * 
 * @export
 * @interface UpdateScenarioRequest
 */
export interface UpdateScenarioRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScenarioRequest
     */
    'prompt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSessionRequest
 */
export interface UpdateSessionRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateSessionRequest
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateSessionRequest
     */
    'voice_override'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUsageLimitsRequest
 */
export interface UpdateUsageLimitsRequest {
    /**
     * 
     * @type {Array<UsageLimitsInner>}
     * @memberof UpdateUsageLimitsRequest
     */
    'limits': Array<UsageLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof UpdateUsageLimitsRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @interface UpdateVoiceRequest
 */
export interface UpdateVoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateVoiceRequest
     */
    'name': string;
    /**
     * The language of the voice
     * @type {string}
     * @memberof UpdateVoiceRequest
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {UsageType}
     * @memberof Usage
     */
    'type': UsageType;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    'value': number;
}


/**
 * 
 * @export
 * @interface UsageLimitsInner
 */
export interface UsageLimitsInner {
    /**
     * 
     * @type {UsageType}
     * @memberof UsageLimitsInner
     */
    'type': UsageType;
    /**
     * 
     * @type {number}
     * @memberof UsageLimitsInner
     */
    'value': number;
}


/**
 * 
 * @export
 * @interface UsageTokenRequest
 */
export interface UsageTokenRequest {
    /**
     * 
     * @type {Array<UsageLimitsInner>}
     * @memberof UsageTokenRequest
     */
    'limits': Array<UsageLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof UsageTokenRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UsageType = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * 
 * @export
 * @interface Voice
 */
export interface Voice {
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'voice'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Voice
     */
    'embeddings'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'cartesia_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'elevenlabs_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'project'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'human_voice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'preview_url'?: string;
    /**
     * Extra configuration for the voice. Usually this is for internal purposes.
     * @type {{ [key: string]: any; }}
     * @memberof Voice
     */
    '_extra'?: { [key: string]: any; };
}
/**
 * @type WebhookMessage
 * @export
 */
export type WebhookMessage = WebhookMessageUsageTracked;

/**
 * 
 * @export
 * @interface WebhookMessageUsageTracked
 */
export interface WebhookMessageUsageTracked {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageUsageTracked
     */
    'type': WebhookMessageUsageTrackedTypeEnum;
    /**
     * 
     * @type {WebhookMessageUsageTrackedPayload}
     * @memberof WebhookMessageUsageTracked
     */
    'payload': WebhookMessageUsageTrackedPayload;
}

export const WebhookMessageUsageTrackedTypeEnum = {
    UsageTracked: 'usage.tracked'
} as const;

export type WebhookMessageUsageTrackedTypeEnum = typeof WebhookMessageUsageTrackedTypeEnum[keyof typeof WebhookMessageUsageTrackedTypeEnum];

/**
 * 
 * @export
 * @interface WebhookMessageUsageTrackedPayload
 */
export interface WebhookMessageUsageTrackedPayload {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'human_id'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'type'?: UsageType;
    /**
     * 
     * @type {number}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'value'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookMessageUsageTrackedPayload
     */
    'extra'?: { [key: string]: any; };
}



/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit: async (createCreditRequest: CreateCreditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCreditRequest' is not null or undefined
            assertParamExists('createCredit', 'createCreditRequest', createCreditRequest)
            const localVarPath = `/api/v1/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCreditLedgerEntry: async (credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('createCreditLedgerEntry', 'credit', credit)
            // verify required parameter 'createCreditLedgerEntryRequest' is not null or undefined
            assertParamExists('createCreditLedgerEntry', 'createCreditLedgerEntryRequest', createCreditLedgerEntryRequest)
            const localVarPath = `/api/v1/credit/{credit}/ledger`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditLedgerEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit: async (credit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('getCredit', 'credit', credit)
            const localVarPath = `/api/v1/credit/{credit}`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCreditLedgerEntry: async (credit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('getLatestCreditLedgerEntry', 'credit', credit)
            const localVarPath = `/api/v1/credit/{credit}/ledger/latest`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/credit/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredit(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredit(credit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredit(credit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getCredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestCreditLedgerEntry(credit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestCreditLedgerEntry(credit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.getLatestCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCredits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.listCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditApiFp(configuration)
    return {
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredit(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.createCredit(createCreditRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(credit: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.getCredit(credit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestCreditLedgerEntry(credit: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.getLatestCreditLedgerEntry(credit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(options?: RawAxiosRequestConfig): AxiosPromise<ListCredits200Response> {
            return localVarFp.listCredits(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * Creates a new credit based on the input request data
     * @summary Create a new credit
     * @param {CreateCreditRequest} createCreditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCredit(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCredit(createCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new credit ledger entry for human. Requires a human id.
     * @summary Create a new credit ledger entry
     * @param {string} credit 
     * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single credit object
     * @param {string} credit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getCredit(credit: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getCredit(credit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest credit ledger entry for a human. Requires a human id.
     * @param {string} credit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getLatestCreditLedgerEntry(credit: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).getLatestCreditLedgerEntry(credit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public listCredits(options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).listCredits(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InferenceApi - axios parameter creator
 * @export
 */
export const InferenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionRequest} chatCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCompletions: async (chatCompletionRequest: ChatCompletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatCompletionRequest' is not null or undefined
            assertParamExists('chatCompletions', 'chatCompletionRequest', chatCompletionRequest)
            const localVarPath = `/api/v1/chat/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatCompletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InferenceApi - functional programming interface
 * @export
 */
export const InferenceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InferenceApiAxiosParamCreator(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionRequest} chatCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatCompletions(chatCompletionRequest: ChatCompletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatCompletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatCompletions(chatCompletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InferenceApi.chatCompletions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InferenceApi - factory interface
 * @export
 */
export const InferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InferenceApiFp(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ChatCompletionRequest} chatCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCompletions(chatCompletionRequest: ChatCompletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatCompletionResponse> {
            return localVarFp.chatCompletions(chatCompletionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InferenceApi - object-oriented interface
 * @export
 * @class InferenceApi
 * @extends {BaseAPI}
 */
export class InferenceApi extends BaseAPI {
    /**
     * Given messages, generates LLM output text and optionally speech
     * @summary Chat Completions (+ Voice)
     * @param {ChatCompletionRequest} chatCompletionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InferenceApi
     */
    public chatCompletions(chatCompletionRequest: ChatCompletionRequest, options?: RawAxiosRequestConfig) {
        return InferenceApiFp(this.configuration).chatCompletions(chatCompletionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMApi - axios parameter creator
 * @export
 */
export const LLMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext: async (contextCreateRequest: ContextCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextCreateRequest' is not null or undefined
            assertParamExists('createContext', 'contextCreateRequest', contextCreateRequest)
            const localVarPath = `/api/v1/llm/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContextMessage: async (context: string, contextMessageCreateParams: ContextMessageCreateParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('createContextMessage', 'context', context)
            // verify required parameter 'contextMessageCreateParams' is not null or undefined
            assertParamExists('createContextMessage', 'contextMessageCreateParams', contextMessageCreateParams)
            const localVarPath = `/api/v1/llm/context/{context}/message`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextMessageCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getContext', 'context', context)
            const localVarPath = `/api/v1/llm/context/{context}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextMessage: async (context: string, message: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('getContextMessage', 'context', context)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('getContextMessage', 'message', message)
            const localVarPath = `/api/v1/llm/context/{context}/message/{message}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"message"}}`, encodeURIComponent(String(message)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLLM: async (llm: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'llm' is not null or undefined
            assertParamExists('getLLM', 'llm', llm)
            const localVarPath = `/api/v1/llm/{llm}`
                .replace(`{${"llm"}}`, encodeURIComponent(String(llm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContextMessages: async (context: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'context' is not null or undefined
            assertParamExists('listContextMessages', 'context', context)
            const localVarPath = `/api/v1/llm/context/{context}/message/list`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLLMs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/llm/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMApi - functional programming interface
 * @export
 */
export const LLMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContext(contextCreateRequest: ContextCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(contextCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContextMessage(context, contextMessageCreateParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContextMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContext(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContextMessage(context: string, message: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextMessage(context, message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContextMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLLM(llm: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LLM>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLLM(llm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.getLLM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContextMessages(context: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContextMessages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContextMessages(context, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.listContextMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLLMs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLLMs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLLMs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.listLLMs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMApi - factory interface
 * @export
 */
export const LLMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMApiFp(configuration)
    return {
        /**
         * Create a new Context with the given configuration. 
         * @summary Create a new Context.
         * @param {ContextCreateRequest} contextCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext(contextCreateRequest: ContextCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Context> {
            return localVarFp.createContext(contextCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ContextMessage with the given configuration. 
         * @summary Create a new ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {ContextMessageCreateParams} contextMessageCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {
            return localVarFp.createContextMessage(context, contextMessageCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the Context with the given identifier. 
         * @summary Retrieve a Context.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(context: string, options?: RawAxiosRequestConfig): AxiosPromise<Context> {
            return localVarFp.getContext(context, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the ContextMessage with the given identifier. 
         * @summary Retrieve a ContextMessage.
         * @param {string} context The unique identifier of the Context.
         * @param {string} message The unique identifier of the ContextMessage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContextMessage(context: string, message: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {
            return localVarFp.getContextMessage(context, message, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {string} llm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLLM(llm: string, options?: RawAxiosRequestConfig): AxiosPromise<LLM> {
            return localVarFp.getLLM(llm, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ContextMessages associated with the given Context. 
         * @summary List ContextMessages.
         * @param {string} context The unique identifier of the Context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContextMessages(context: string, options?: RawAxiosRequestConfig): AxiosPromise<ListContextMessages200Response> {
            return localVarFp.listContextMessages(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLLMs(options?: RawAxiosRequestConfig): AxiosPromise<ListLLMs200Response> {
            return localVarFp.listLLMs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMApi - object-oriented interface
 * @export
 * @class LLMApi
 * @extends {BaseAPI}
 */
export class LLMApi extends BaseAPI {
    /**
     * Create a new Context with the given configuration. 
     * @summary Create a new Context.
     * @param {ContextCreateRequest} contextCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public createContext(contextCreateRequest: ContextCreateRequest, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).createContext(contextCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ContextMessage with the given configuration. 
     * @summary Create a new ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {ContextMessageCreateParams} contextMessageCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).createContextMessage(context, contextMessageCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the Context with the given identifier. 
     * @summary Retrieve a Context.
     * @param {string} context The unique identifier of the Context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getContext(context: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getContext(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the ContextMessage with the given identifier. 
     * @summary Retrieve a ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {string} message The unique identifier of the ContextMessage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getContextMessage(context: string, message: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getContextMessage(context, message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of llms
     * @param {string} llm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public getLLM(llm: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).getLLM(llm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ContextMessages associated with the given Context. 
     * @summary List ContextMessages.
     * @param {string} context The unique identifier of the Context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public listContextMessages(context: string, options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).listContextMessages(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of llms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public listLLMs(options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).listLLMs(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona: async (createPersonaRequest: CreatePersonaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonaRequest' is not null or undefined
            assertParamExists('createPersona', 'createPersonaRequest', createPersonaRequest)
            const localVarPath = `/api/v1/persona`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona: async (personaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('deletePersona', 'personaId', personaId)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersona: async (personaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPersona', 'personaId', personaId)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/persona/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona: async (personaId: string, updatePersonaRequest: UpdatePersonaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('updatePersona', 'personaId', personaId)
            // verify required parameter 'updatePersonaRequest' is not null or undefined
            assertParamExists('updatePersona', 'updatePersonaRequest', updatePersonaRequest)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.createPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersona(personaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePersona200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.deletePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersona(personaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersona(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.getPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPersonas200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.listPersonas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(personaId, updatePersonaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.updatePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.createPersona(createPersonaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona(personaId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletePersona200Response> {
            return localVarFp.deletePersona(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersona(personaId: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getPersona(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas(options?: RawAxiosRequestConfig): AxiosPromise<ListPersonas200Response> {
            return localVarFp.listPersonas(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a persona
         * @param {string} personaId 
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.updatePersona(personaId, updatePersonaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * 
     * @summary Get a persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).createPersona(createPersonaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public deletePersona(personaId: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).deletePersona(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public getPersona(personaId: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).getPersona(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of personas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public listPersonas(options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).listPersonas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a persona
     * @param {string} personaId 
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).updatePersona(personaId, updatePersonaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealtimeApi - axios parameter creator
 * @export
 */
export const RealtimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endRealtimeSession: async (session: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('endRealtimeSession', 'session', session)
            const localVarPath = `/api/v1/realtime/{session}/end`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSession: async (session: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('getRealtimeSession', 'session', session)
            const localVarPath = `/api/v1/realtime/{session}`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealtimeSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/realtime/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRealtimeSession: async (startRealtimeSessionRequest: StartRealtimeSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startRealtimeSessionRequest' is not null or undefined
            assertParamExists('startRealtimeSession', 'startRealtimeSessionRequest', startRealtimeSessionRequest)
            const localVarPath = `/api/v1/realtime/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRealtimeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealtimeSession: async (session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('updateRealtimeSession', 'session', session)
            // verify required parameter 'realtimeSessionConfigUpdate' is not null or undefined
            assertParamExists('updateRealtimeSession', 'realtimeSessionConfigUpdate', realtimeSessionConfigUpdate)
            const localVarPath = `/api/v1/realtime/{session}/update`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionConfigUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealtimeApi - functional programming interface
 * @export
 */
export const RealtimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration)
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endRealtimeSession(session: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endRealtimeSession(session, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.endRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimeSession(session: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSession(session, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRealtimeSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRealtimeSessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRealtimeSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.listRealtimeSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSessionStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRealtimeSession(startRealtimeSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.startRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRealtimeSession(session, realtimeSessionConfigUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.updateRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealtimeApi - factory interface
 * @export
 */
export const RealtimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealtimeApiFp(configuration)
    return {
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endRealtimeSession(session: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.endRealtimeSession(session, options).then((request) => request(axios, basePath));
        },
        /**
         * End the RealtimeSession with the given identifier. 
         * @summary End a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimeSession(session: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.getRealtimeSession(session, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Realtime Sessions. 
         * @summary List Realtime Sessions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRealtimeSessions(options?: RawAxiosRequestConfig): AxiosPromise<ListRealtimeSessions200Response> {
            return localVarFp.listRealtimeSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * Start a new RealtimeSession with the given configuration. 
         * @summary Start a new RealtimeSession.
         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSessionStartResponse> {
            return localVarFp.startRealtimeSession(startRealtimeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the RealtimeSession with the given identifier. 
         * @summary Update a RealtimeSession.
         * @param {string} session The unique identifier of the RealtimeSession.
         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {
            return localVarFp.updateRealtimeSession(session, realtimeSessionConfigUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealtimeApi - object-oriented interface
 * @export
 * @class RealtimeApi
 * @extends {BaseAPI}
 */
export class RealtimeApi extends BaseAPI {
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public endRealtimeSession(session: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).endRealtimeSession(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public getRealtimeSession(session: string, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).getRealtimeSession(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Realtime Sessions. 
     * @summary List Realtime Sessions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public listRealtimeSessions(options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).listRealtimeSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a new RealtimeSession with the given configuration. 
     * @summary Start a new RealtimeSession.
     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).startRealtimeSession(startRealtimeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the RealtimeSession with the given identifier. 
     * @summary Update a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    public updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).updateRealtimeSession(session, realtimeSessionConfigUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario: async (createScenarioRequest: CreateScenarioRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScenarioRequest' is not null or undefined
            assertParamExists('createScenario', 'createScenarioRequest', createScenarioRequest)
            const localVarPath = `/api/v1/scenario`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario: async (scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenario', 'scenarioId', scenarioId)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenario: async (scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenario', 'scenarioId', scenarioId)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenarios: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/scenario/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario: async (scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenario', 'scenarioId', scenarioId)
            // verify required parameter 'updateScenarioRequest' is not null or undefined
            assertParamExists('updateScenario', 'updateScenarioRequest', updateScenarioRequest)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateScenarioRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(createScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.createScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenario(scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteScenario200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.deleteScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenario(scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenario(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScenarios(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListScenarios200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScenarios(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.listScenarios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(scenarioId, updateScenarioRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.updateScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {CreateScenarioRequest} createScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.createScenario(createScenarioRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario(scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteScenario200Response> {
            return localVarFp.deleteScenario(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenario(scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.getScenario(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScenarios(options?: RawAxiosRequestConfig): AxiosPromise<ListScenarios200Response> {
            return localVarFp.listScenarios(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} scenarioId 
         * @param {UpdateScenarioRequest} updateScenarioRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.updateScenario(scenarioId, updateScenarioRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Create a scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).createScenario(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteScenario(scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteScenario(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenario(scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenario(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public listScenarios(options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).listScenarios(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scenario
     * @param {string} scenarioId 
     * @param {UpdateScenarioRequest} updateScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenario(scenarioId, updateScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionListGet: async (human?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/session/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (human !== undefined) {
                localVarQueryParameter['human'] = human;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdEndPost', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/end`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdMessagesGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/messages`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {UpdateSessionRequest} updateSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut: async (sessionId: string, updateSessionRequest: UpdateSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'sessionId', sessionId)
            // verify required parameter 'updateSessionRequest' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'updateSessionRequest', updateSessionRequest)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdTimelineGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/timeline`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {SessionStartRequest} sessionStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost: async (sessionStartRequest: SessionStartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionStartRequest' is not null or undefined
            assertParamExists('apiV1SessionStartPost', 'sessionStartRequest', sessionStartRequest)
            const localVarPath = `/api/v1/session/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionListGet(human, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdEndPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {UpdateSessionRequest} updateSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdPut(sessionId: string, updateSessionRequest: UpdateSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdTimelineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {SessionStartRequest} sessionStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionStartPost(sessionStartRequest: SessionStartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(sessionStartRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionListGet200Response> {
            return localVarFp.apiV1SessionListGet(human, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.apiV1SessionSessionIdGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response> {
            return localVarFp.apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {UpdateSessionRequest} updateSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut(sessionId: string, updateSessionRequest: UpdateSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response> {
            return localVarFp.apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {SessionStartRequest} sessionStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost(sessionStartRequest: SessionStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<SessionStartResponse> {
            return localVarFp.apiV1SessionStartPost(sessionStartRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of sessions
     * @param {string} [human] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionListGet(human, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {UpdateSessionRequest} updateSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdPut(sessionId: string, updateSessionRequest: UpdateSessionRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new session based on the input request data
     * @summary Create a new session
     * @param {SessionStartRequest} sessionStartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionStartPost(sessionStartRequest: SessionStartRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionStartPost(sessionStartRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UsageTokenRequest} usageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageToken: async (usageTokenRequest: UsageTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usageTokenRequest' is not null or undefined
            assertParamExists('createUsageToken', 'usageTokenRequest', usageTokenRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usageTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/usage/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the usage limits of a human
         * @summary Update limits on a usage token
         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageToken: async (updateUsageLimitsRequest: UpdateUsageLimitsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUsageLimitsRequest' is not null or undefined
            assertParamExists('updateUsageToken', 'updateUsageLimitsRequest', updateUsageLimitsRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageLimitsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UsageTokenRequest} usageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsageToken(usageTokenRequest: UsageTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUsageToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageToken(usageTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.createUsageToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageLimitsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.getUsageLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the usage limits of a human
         * @summary Update limits on a usage token
         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageToken(updateUsageLimitsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.updateUsageToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {UsageTokenRequest} usageTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsageToken(usageTokenRequest: UsageTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUsageToken200Response> {
            return localVarFp.createUsageToken(usageTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageLimits(options?: RawAxiosRequestConfig): AxiosPromise<Array<UsageLimitsInner>> {
            return localVarFp.getUsageLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the usage limits of a human
         * @summary Update limits on a usage token
         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {UsageTokenRequest} usageTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public createUsageToken(usageTokenRequest: UsageTokenRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).createUsageToken(usageTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsageLimits(options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).getUsageLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the usage limits of a human
     * @summary Update limits on a usage token
     * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceApi - axios parameter creator
 * @export
 */
export const VoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneVoice: async (name: string, language: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('cloneVoice', 'name', name)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('cloneVoice', 'language', language)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('cloneVoice', 'file', file)
            const localVarPath = `/api/v1/voice/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('deleteVoice', 'voiceId', voiceId)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateVoice: async (generateVoiceRequest: GenerateVoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateVoiceRequest' is not null or undefined
            assertParamExists('generateVoice', 'generateVoiceRequest', generateVoiceRequest)
            const localVarPath = `/api/v1/voice/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateVoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('getVoice', 'voiceId', voiceId)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/voice/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoice: async (voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('updateVoice', 'voiceId', voiceId)
            // verify required parameter 'updateVoiceRequest' is not null or undefined
            assertParamExists('updateVoice', 'updateVoiceRequest', updateVoiceRequest)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceApi - functional programming interface
 * @export
 */
export const VoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneVoice(name: string, language: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloneVoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneVoice(name, language, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.cloneVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoice(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.deleteVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateVoice(generateVoiceRequest: GenerateVoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateVoice(generateVoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.generateVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoice(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.getVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVoices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVoices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.listVoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoice(voiceId, updateVoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.updateVoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceApi - factory interface
 * @export
 */
export const VoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceApiFp(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneVoice(name: string, language: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<CloneVoice200Response> {
            return localVarFp.cloneVoice(name, language, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVoice200Response> {
            return localVarFp.deleteVoice(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {GenerateVoiceRequest} generateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateVoice(generateVoiceRequest: GenerateVoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.generateVoice(generateVoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.getVoice(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVoices(options?: RawAxiosRequestConfig): AxiosPromise<ListVoices200Response> {
            return localVarFp.listVoices(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {UpdateVoiceRequest} updateVoiceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {
            return localVarFp.updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceApi - object-oriented interface
 * @export
 * @class VoiceApi
 * @extends {BaseAPI}
 */
export class VoiceApi extends BaseAPI {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public cloneVoice(name: string, language: string, file: File, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).cloneVoice(name, language, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public deleteVoice(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).deleteVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {GenerateVoiceRequest} generateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public generateVoice(generateVoiceRequest: GenerateVoiceRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).generateVoice(generateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public getVoice(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).getVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of voices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public listVoices(options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).listVoices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {UpdateVoiceRequest} updateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



