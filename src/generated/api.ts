/* tslint:disable */
/* eslint-disable */
/**
 * Session API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 
 * @export
 * @interface ApiV1ChatCompletionsPost200Response
 */
export interface ApiV1ChatCompletionsPost200Response {
    /**
     * A list of chat completion choices.
     * @type {Array<ApiV1ChatCompletionsPost200ResponseChoicesInner>}
     * @memberof ApiV1ChatCompletionsPost200Response
     */
    'choices': Array<ApiV1ChatCompletionsPost200ResponseChoicesInner>;
    /**
     * The model used for completion.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response
     */
    'model': string;
}
/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 * @export
 * @interface ApiV1ChatCompletionsPost200Response1
 */
export interface ApiV1ChatCompletionsPost200Response1 {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1
     */
    'id': string;
    /**
     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
     * @type {Array<ApiV1ChatCompletionsPost200Response1ChoicesInner>}
     * @memberof ApiV1ChatCompletionsPost200Response1
     */
    'choices': Array<ApiV1ChatCompletionsPost200Response1ChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     * @type {number}
     * @memberof ApiV1ChatCompletionsPost200Response1
     */
    'created': number;
    /**
     * The model to generate the completion.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1
     */
    'model': string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1
     */
    'object': ApiV1ChatCompletionsPost200Response1ObjectEnum;
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200Response1Gabber}
     * @memberof ApiV1ChatCompletionsPost200Response1
     */
    'gabber'?: ApiV1ChatCompletionsPost200Response1Gabber;
}

export const ApiV1ChatCompletionsPost200Response1ObjectEnum = {
    ChatCompletionChunk: 'chat.completion.chunk'
} as const;

export type ApiV1ChatCompletionsPost200Response1ObjectEnum = typeof ApiV1ChatCompletionsPost200Response1ObjectEnum[keyof typeof ApiV1ChatCompletionsPost200Response1ObjectEnum];

/**
 * 
 * @export
 * @interface ApiV1ChatCompletionsPost200Response1ChoicesInner
 */
export interface ApiV1ChatCompletionsPost200Response1ChoicesInner {
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInner
     */
    'delta': ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta;
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInner
     */
    'finish_reason': ApiV1ChatCompletionsPost200Response1ChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInner
     */
    'index': number;
}

export const ApiV1ChatCompletionsPost200Response1ChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ToolCalls: 'tool_calls',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
} as const;

export type ApiV1ChatCompletionsPost200Response1ChoicesInnerFinishReasonEnum = typeof ApiV1ChatCompletionsPost200Response1ChoicesInnerFinishReasonEnum[keyof typeof ApiV1ChatCompletionsPost200Response1ChoicesInnerFinishReasonEnum];

/**
 * A chat completion delta generated by streamed model responses.
 * @export
 * @interface ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta
 */
export interface ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta {
    /**
     * The contents of the chunk message.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta
     */
    'content'?: string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta
     */
    'role'?: ApiV1ChatCompletionsPost200Response1ChoicesInnerDeltaRoleEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta
     */
    'refusal'?: string;
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber}
     * @memberof ApiV1ChatCompletionsPost200Response1ChoicesInnerDelta
     */
    'gabber'?: ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber;
}

export const ApiV1ChatCompletionsPost200Response1ChoicesInnerDeltaRoleEnum = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant'
} as const;

export type ApiV1ChatCompletionsPost200Response1ChoicesInnerDeltaRoleEnum = typeof ApiV1ChatCompletionsPost200Response1ChoicesInnerDeltaRoleEnum[keyof typeof ApiV1ChatCompletionsPost200Response1ChoicesInnerDeltaRoleEnum];

/**
 * Gabber-specific fields
 * @export
 * @interface ApiV1ChatCompletionsPost200Response1Gabber
 */
export interface ApiV1ChatCompletionsPost200Response1Gabber {
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200Response1GabberUsage}
     * @memberof ApiV1ChatCompletionsPost200Response1Gabber
     */
    'usage'?: ApiV1ChatCompletionsPost200Response1GabberUsage;
}
/**
 * Gabber usage for this request
 * @export
 * @interface ApiV1ChatCompletionsPost200Response1GabberUsage
 */
export interface ApiV1ChatCompletionsPost200Response1GabberUsage {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200Response1GabberUsage
     */
    'type': ApiV1ChatCompletionsPost200Response1GabberUsageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ApiV1ChatCompletionsPost200Response1GabberUsage
     */
    'value': number;
}

export const ApiV1ChatCompletionsPost200Response1GabberUsageTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type ApiV1ChatCompletionsPost200Response1GabberUsageTypeEnum = typeof ApiV1ChatCompletionsPost200Response1GabberUsageTypeEnum[keyof typeof ApiV1ChatCompletionsPost200Response1GabberUsageTypeEnum];

/**
 * 
 * @export
 * @interface ApiV1ChatCompletionsPost200ResponseChoicesInner
 */
export interface ApiV1ChatCompletionsPost200ResponseChoicesInner {
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInner
     */
    'message': ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage;
}
/**
 * A chat completion message generated by the model.
 * @export
 * @interface ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage
 */
export interface ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage {
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage
     */
    'content': string;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage
     */
    'refusal': string;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage
     */
    'role': ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageRoleEnum;
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessage
     */
    'gabber'?: ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber;
}

export const ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageRoleEnum = typeof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageRoleEnum[keyof typeof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageRoleEnum];

/**
 * If the audio output modality is requested, this object contains data
 * @export
 * @interface ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber
 */
export interface ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber {
    /**
     * 
     * @type {ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabberVoice}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabber
     */
    'voice'?: ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabberVoice;
}
/**
 * 
 * @export
 * @interface ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabberVoice
 */
export interface ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabberVoice {
    /**
     * This will be the URL to the audio file
     * @type {string}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabberVoice
     */
    'audio_url': string;
    /**
     * The Unix timestamp (in seconds) when the audio file expires
     * @type {number}
     * @memberof ApiV1ChatCompletionsPost200ResponseChoicesInnerMessageGabberVoice
     */
    'expires_at': number;
}
/**
 * 
 * @export
 * @interface ApiV1ChatCompletionsPostRequest
 */
export interface ApiV1ChatCompletionsPostRequest {
    /**
     * Chat context
     * @type {Array<ApiV1ChatCompletionsPostRequestMessagesInner>}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'messages': Array<ApiV1ChatCompletionsPostRequestMessagesInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'model': string;
    /**
     * 
     * @type {object}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'metadata'?: object;
    /**
     * 
     * @type {ApiV1ChatCompletionsPostRequestGabber}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'gabber'?: ApiV1ChatCompletionsPostRequestGabber;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. 
     * @type {boolean}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'stream'?: boolean;
    /**
     * Temperature for sampling from the model. Higher values mean more randomness. 
     * @type {number}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'temperature'?: number;
    /**
     * Maximum number of tokens to generate. Requests can be up to 4096 tokens. 
     * @type {number}
     * @memberof ApiV1ChatCompletionsPostRequest
     */
    'max_tokens'?: number;
}
/**
 * 
 * @export
 * @interface ApiV1ChatCompletionsPostRequestGabber
 */
export interface ApiV1ChatCompletionsPostRequestGabber {
    /**
     * Gabber voice id
     * @type {string}
     * @memberof ApiV1ChatCompletionsPostRequestGabber
     */
    'voice'?: string;
}
/**
 * @type ApiV1ChatCompletionsPostRequestMessagesInner
 * @export
 */
export type ApiV1ChatCompletionsPostRequestMessagesInner = AssistantMessage | SystemMessage | UserMessage;

/**
 * 
 * @export
 * @interface ApiV1CreditListGet200Response
 */
export interface ApiV1CreditListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1CreditListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1CreditListGet200Response
     */
    'total_count': number;
    /**
     * The array of credits.
     * @type {Array<Credit>}
     * @memberof ApiV1CreditListGet200Response
     */
    'values': Array<Credit>;
}
/**
 * 
 * @export
 * @interface ApiV1LlmListGet200Response
 */
export interface ApiV1LlmListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1LlmListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1LlmListGet200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<LLM>}
     * @memberof ApiV1LlmListGet200Response
     */
    'values': Array<LLM>;
}
/**
 * 
 * @export
 * @interface ApiV1PersonaListGet200Response
 */
export interface ApiV1PersonaListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1PersonaListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1PersonaListGet200Response
     */
    'total_count': number;
    /**
     * The array of personas.
     * @type {Array<Persona>}
     * @memberof ApiV1PersonaListGet200Response
     */
    'values': Array<Persona>;
}
/**
 * 
 * @export
 * @interface ApiV1PersonaPersonaIdDelete200Response
 */
export interface ApiV1PersonaPersonaIdDelete200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1PersonaPersonaIdDelete200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1ScenarioListGet200Response
 */
export interface ApiV1ScenarioListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1ScenarioListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1ScenarioListGet200Response
     */
    'total_count': number;
    /**
     * The array of scenarios.
     * @type {Array<Scenario>}
     * @memberof ApiV1ScenarioListGet200Response
     */
    'values': Array<Scenario>;
}
/**
 * 
 * @export
 * @interface ApiV1ScenarioScenarioIdDelete200Response
 */
export interface ApiV1ScenarioScenarioIdDelete200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ScenarioScenarioIdDelete200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionListGet200Response
 */
export interface ApiV1SessionListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionListGet200Response
     */
    'total_count': number;
    /**
     * The array of sessions.
     * @type {Array<Session>}
     * @memberof ApiV1SessionListGet200Response
     */
    'values': Array<Session>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdMessagesGet200Response
 */
export interface ApiV1SessionSessionIdMessagesGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'total_count': number;
    /**
     * The array of session timeline items.
     * @type {Array<SessionMessage>}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'values': Array<SessionMessage>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdPutRequest
 */
export interface ApiV1SessionSessionIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionSessionIdPutRequest
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdPutRequest
     */
    'voice_override'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdTimelineGet200Response
 */
export interface ApiV1SessionSessionIdTimelineGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'next_page'?: string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'total_count'?: number;
    /**
     * The array of session timeline items.
     * @type {Array<SessionTimelineItem>}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'values'?: Array<SessionTimelineItem>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200Response
 */
export interface ApiV1SessionStartPost200Response {
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseSession}
     * @memberof ApiV1SessionStartPost200Response
     */
    'session': ApiV1SessionStartPost200ResponseSession;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponsePersona}
     * @memberof ApiV1SessionStartPost200Response
     */
    'persona'?: ApiV1SessionStartPost200ResponsePersona;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseScenario}
     * @memberof ApiV1SessionStartPost200Response
     */
    'scenario'?: ApiV1SessionStartPost200ResponseScenario;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseConnectionDetails}
     * @memberof ApiV1SessionStartPost200Response
     */
    'connection_details': ApiV1SessionStartPost200ResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseConnectionDetails
 */
export interface ApiV1SessionStartPost200ResponseConnectionDetails {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseConnectionDetails
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseConnectionDetails
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponsePersona
 */
export interface ApiV1SessionStartPost200ResponsePersona {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'image_url': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'gender'?: ApiV1SessionStartPost200ResponsePersonaGenderEnum;
    /**
     * 
     * @type {Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'tags': Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'voice': string;
}

export const ApiV1SessionStartPost200ResponsePersonaGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type ApiV1SessionStartPost200ResponsePersonaGenderEnum = typeof ApiV1SessionStartPost200ResponsePersonaGenderEnum[keyof typeof ApiV1SessionStartPost200ResponsePersonaGenderEnum];

/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponsePersonaTagsInner
 */
export interface ApiV1SessionStartPost200ResponsePersonaTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersonaTagsInner
     */
    'human_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersonaTagsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseScenario
 */
export interface ApiV1SessionStartPost200ResponseScenario {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseSession
 */
export interface ApiV1SessionStartPost200ResponseSession {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'state': ApiV1SessionStartPost200ResponseSessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'time_limit_s': number;
}

export const ApiV1SessionStartPost200ResponseSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type ApiV1SessionStartPost200ResponseSessionStateEnum = typeof ApiV1SessionStartPost200ResponseSessionStateEnum[keyof typeof ApiV1SessionStartPost200ResponseSessionStateEnum];

/**
 * @type ApiV1SessionStartPostRequest
 * @export
 */
export type ApiV1SessionStartPostRequest = ApiV1SessionStartPostRequestOneOf | ApiV1SessionStartPostRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOf
 */
export interface ApiV1SessionStartPostRequestOneOf {
    /**
     * 
     * @type {Array<ApiV1SessionStartPostRequestOneOfHistoryInner>}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'history'?: Array<ApiV1SessionStartPostRequestOneOfHistoryInner>;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOf1
 */
export interface ApiV1SessionStartPostRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'scenario'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOfHistoryInner
 */
export interface ApiV1SessionStartPostRequestOneOfHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'role': ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum;
}

export const ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum = typeof ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum[keyof typeof ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum];

/**
 * 
 * @export
 * @interface ApiV1UsageTokenPost200Response
 */
export interface ApiV1UsageTokenPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsageTokenPost200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ApiV1UsageTokenPutRequest
 */
export interface ApiV1UsageTokenPutRequest {
    /**
     * 
     * @type {Array<ApiV1UsageTokenPutRequestLimitsInner>}
     * @memberof ApiV1UsageTokenPutRequest
     */
    'limits': Array<ApiV1UsageTokenPutRequestLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof ApiV1UsageTokenPutRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @interface ApiV1UsageTokenPutRequestLimitsInner
 */
export interface ApiV1UsageTokenPutRequestLimitsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsageTokenPutRequestLimitsInner
     */
    'type': ApiV1UsageTokenPutRequestLimitsInnerTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ApiV1UsageTokenPutRequestLimitsInner
     */
    'value': number;
}

export const ApiV1UsageTokenPutRequestLimitsInnerTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type ApiV1UsageTokenPutRequestLimitsInnerTypeEnum = typeof ApiV1UsageTokenPutRequestLimitsInnerTypeEnum[keyof typeof ApiV1UsageTokenPutRequestLimitsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiV1VoiceClonePost200Response
 */
export interface ApiV1VoiceClonePost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceClonePost200Response
     */
    'message': string;
    /**
     * Name of the cloned voice
     * @type {string}
     * @memberof ApiV1VoiceClonePost200Response
     */
    'name': string;
    /**
     * Language of the cloned voice
     * @type {string}
     * @memberof ApiV1VoiceClonePost200Response
     */
    'language': string;
    /**
     * Unique identifier of the cloned voice
     * @type {string}
     * @memberof ApiV1VoiceClonePost200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceGeneratePostRequest
 */
export interface ApiV1VoiceGeneratePostRequest {
    /**
     * Text to synthesize into voice
     * @type {string}
     * @memberof ApiV1VoiceGeneratePostRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceGeneratePostRequest
     */
    'voice_id': string;
    /**
     * Whether to moderate the text.
     * @type {boolean}
     * @memberof ApiV1VoiceGeneratePostRequest
     */
    'moderation'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceListGet200Response
 */
export interface ApiV1VoiceListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1VoiceListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1VoiceListGet200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<Voice>}
     * @memberof ApiV1VoiceListGet200Response
     */
    'values': Array<Voice>;
}
/**
 * 
 * @export
 * @interface ApiV1VoicePreviewPostRequest
 */
export interface ApiV1VoicePreviewPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoicePreviewPostRequest
     */
    'voice': string;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceVoiceIdDelete200Response
 */
export interface ApiV1VoiceVoiceIdDelete200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceVoiceIdDelete200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceVoiceIdPut200Response
 */
export interface ApiV1VoiceVoiceIdPut200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceVoiceIdPut200Response
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceVoiceIdPut200Response
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceVoiceIdPut200Response
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceVoiceIdPutRequest
 */
export interface ApiV1VoiceVoiceIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceVoiceIdPutRequest
     */
    'name': string;
    /**
     * The language of the voice
     * @type {string}
     * @memberof ApiV1VoiceVoiceIdPutRequest
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface AssistantMessage
 */
export interface AssistantMessage {
    /**
     * 
     * @type {AssistantMessageContent}
     * @memberof AssistantMessage
     */
    'content': AssistantMessageContent;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof AssistantMessage
     */
    'refusal'?: string;
    /**
     * The role of the messages author, in this case `assistant`.
     * @type {string}
     * @memberof AssistantMessage
     */
    'role': AssistantMessageRoleEnum;
}

export const AssistantMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type AssistantMessageRoleEnum = typeof AssistantMessageRoleEnum[keyof typeof AssistantMessageRoleEnum];

/**
 * @type AssistantMessageContent
 * The contents of the assistant message. 
 * @export
 */
export type AssistantMessageContent = Array<AssistantMessageContentOneOfInner> | string;

/**
 * @type AssistantMessageContentOneOfInner
 * @export
 */
export type AssistantMessageContentOneOfInner = RefusalContentPart | TextContentPart;

/**
 * 
 * @export
 * @interface CreateCreditLedgerEntryRequest
 */
export interface CreateCreditLedgerEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateCreditLedgerEntryRequest
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface CreateCreditRequest
 */
export interface CreateCreditRequest {
    /**
     * The name of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof CreateCreditRequest
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof CreateCreditRequest
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * The date and time the credit was created.
     * @type {string}
     * @memberof Credit
     */
    'created_at': string;
    /**
     * The unique identifier of the credit.
     * @type {string}
     * @memberof Credit
     */
    'id': string;
    /**
     * The project the credit belongs to.
     * @type {string}
     * @memberof Credit
     */
    'project': string;
    /**
     * The name of the credit.
     * @type {string}
     * @memberof Credit
     */
    'name': string;
    /**
     * The description of the credit.
     * @type {string}
     * @memberof Credit
     */
    'description': string;
    /**
     * Whether the credit can have a negative balance.
     * @type {boolean}
     * @memberof Credit
     */
    'allow_negative_balance': boolean;
}
/**
 * 
 * @export
 * @interface CreditLedgerEntry
 */
export interface CreditLedgerEntry {
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'credit': string;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'human': string;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'amount': number;
    /**
     * 
     * @type {number}
     * @memberof CreditLedgerEntry
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CreditLedgerEntry
     */
    'idempotency_key': string;
}
/**
 * 
 * @export
 * @interface HistoryMessage
 */
export interface HistoryMessage {
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryMessage
     */
    'role': HistoryMessageRoleEnum;
}

export const HistoryMessageRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type HistoryMessageRoleEnum = typeof HistoryMessageRoleEnum[keyof typeof HistoryMessageRoleEnum];

/**
 * @type InlineObject
 * @export
 */
export type InlineObject = InlineObjectOneOf | InlineObjectOneOf1 | InlineObjectOneOf2;

/**
 * 
 * @export
 * @interface InlineObjectOneOf
 */
export interface InlineObjectOneOf {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf
     */
    'type'?: InlineObjectOneOfTypeEnum;
}

export const InlineObjectOneOfTypeEnum = {
    UsageLimitExceeded: 'usage_limit_exceeded'
} as const;

export type InlineObjectOneOfTypeEnum = typeof InlineObjectOneOfTypeEnum[keyof typeof InlineObjectOneOfTypeEnum];

/**
 * 
 * @export
 * @interface InlineObjectOneOf1
 */
export interface InlineObjectOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf1
     */
    'type'?: InlineObjectOneOf1TypeEnum;
}

export const InlineObjectOneOf1TypeEnum = {
    ProjectDisabled: 'project_disabled'
} as const;

export type InlineObjectOneOf1TypeEnum = typeof InlineObjectOneOf1TypeEnum[keyof typeof InlineObjectOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface InlineObjectOneOf2
 */
export interface InlineObjectOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObjectOneOf2
     */
    'type'?: InlineObjectOneOf2TypeEnum;
}

export const InlineObjectOneOf2TypeEnum = {
    ModerationError: 'moderation_error'
} as const;

export type InlineObjectOneOf2TypeEnum = typeof InlineObjectOneOf2TypeEnum[keyof typeof InlineObjectOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface LLM
 */
export interface LLM {
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LLM
     */
    'project': string;
}
/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'image_url': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>}
     * @memberof Persona
     */
    'tags': Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'voice': string;
}

export const PersonaGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type PersonaGenderEnum = typeof PersonaGenderEnum[keyof typeof PersonaGenderEnum];

/**
 * 
 * @export
 * @interface RefusalContentPart
 */
export interface RefusalContentPart {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof RefusalContentPart
     */
    'type': RefusalContentPartTypeEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof RefusalContentPart
     */
    'refusal': string;
}

export const RefusalContentPartTypeEnum = {
    Refusal: 'refusal'
} as const;

export type RefusalContentPartTypeEnum = typeof RefusalContentPartTypeEnum[keyof typeof RefusalContentPartTypeEnum];

/**
 * 
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof Session
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'state': SessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'time_limit_s': number;
}

export const SessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type SessionStateEnum = typeof SessionStateEnum[keyof typeof SessionStateEnum];

/**
 * 
 * @export
 * @interface SessionMessage
 */
export interface SessionMessage {
    /**
     * 
     * @type {boolean}
     * @memberof SessionMessage
     */
    'agent': boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'import_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'media'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'session': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'speaking_ended_at': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMessage
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface SessionTimelineItem
 */
export interface SessionTimelineItem {
    /**
     * 
     * @type {number}
     * @memberof SessionTimelineItem
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof SessionTimelineItem
     */
    'type'?: SessionTimelineItemTypeEnum;
}

export const SessionTimelineItemTypeEnum = {
    Silence: 'silence',
    Agent: 'agent',
    User: 'user'
} as const;

export type SessionTimelineItemTypeEnum = typeof SessionTimelineItemTypeEnum[keyof typeof SessionTimelineItemTypeEnum];

/**
 * 
 * @export
 * @interface SystemMessage
 */
export interface SystemMessage {
    /**
     * 
     * @type {SystemMessageContent}
     * @memberof SystemMessage
     */
    'content': SystemMessageContent;
    /**
     * The role of the messages author, in this case `system`.
     * @type {string}
     * @memberof SystemMessage
     */
    'role': SystemMessageRoleEnum;
}

export const SystemMessageRoleEnum = {
    System: 'system'
} as const;

export type SystemMessageRoleEnum = typeof SystemMessageRoleEnum[keyof typeof SystemMessageRoleEnum];

/**
 * @type SystemMessageContent
 * The contents of the system message.
 * @export
 */
export type SystemMessageContent = Array<SystemMessageContentOneOfInner> | string;

/**
 * @type SystemMessageContentOneOfInner
 * @export
 */
export type SystemMessageContentOneOfInner = TextContentPart;

/**
 * Text content
 * @export
 * @interface TextContentPart
 */
export interface TextContentPart {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof TextContentPart
     */
    'type': TextContentPartTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof TextContentPart
     */
    'text': string;
}

export const TextContentPartTypeEnum = {
    Text: 'text'
} as const;

export type TextContentPartTypeEnum = typeof TextContentPartTypeEnum[keyof typeof TextContentPartTypeEnum];

/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    'type': UsageTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    'value': number;
}

export const UsageTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type UsageTypeEnum = typeof UsageTypeEnum[keyof typeof UsageTypeEnum];

/**
 * 
 * @export
 * @interface UserMessage
 */
export interface UserMessage {
    /**
     * 
     * @type {UserMessageContent}
     * @memberof UserMessage
     */
    'content': UserMessageContent;
    /**
     * The role of the messages author, in this case `user`.
     * @type {string}
     * @memberof UserMessage
     */
    'role': UserMessageRoleEnum;
}

export const UserMessageRoleEnum = {
    User: 'user'
} as const;

export type UserMessageRoleEnum = typeof UserMessageRoleEnum[keyof typeof UserMessageRoleEnum];

/**
 * @type UserMessageContent
 * The contents of the user message.
 * @export
 */
export type UserMessageContent = Array<SystemMessageContentOneOfInner> | string;

/**
 * 
 * @export
 * @interface Voice
 */
export interface Voice {
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Voice
     */
    'language': string;
}

/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditCreditGet: async (credit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('apiV1CreditCreditGet', 'credit', credit)
            const localVarPath = `/api/v1/credit/{credit}`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditCreditLedgerLatestGet: async (credit: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('apiV1CreditCreditLedgerLatestGet', 'credit', credit)
            const localVarPath = `/api/v1/credit/{credit}/ledger/latest`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditCreditLedgerPost: async (credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credit' is not null or undefined
            assertParamExists('apiV1CreditCreditLedgerPost', 'credit', credit)
            // verify required parameter 'createCreditLedgerEntryRequest' is not null or undefined
            assertParamExists('apiV1CreditCreditLedgerPost', 'createCreditLedgerEntryRequest', createCreditLedgerEntryRequest)
            const localVarPath = `/api/v1/credit/{credit}/ledger`
                .replace(`{${"credit"}}`, encodeURIComponent(String(credit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditLedgerEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/credit/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditPost: async (createCreditRequest: CreateCreditRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCreditRequest' is not null or undefined
            assertParamExists('apiV1CreditPost', 'createCreditRequest', createCreditRequest)
            const localVarPath = `/api/v1/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CreditCreditGet(credit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CreditCreditGet(credit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.apiV1CreditCreditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CreditCreditLedgerLatestGet(credit: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CreditCreditLedgerLatestGet(credit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.apiV1CreditCreditLedgerLatestGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CreditCreditLedgerPost(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CreditCreditLedgerPost(credit, createCreditLedgerEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.apiV1CreditCreditLedgerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CreditListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1CreditListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CreditListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.apiV1CreditListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CreditPost(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CreditPost(createCreditRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditApi.apiV1CreditPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single credit object
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditCreditGet(credit: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.apiV1CreditCreditGet(credit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest credit ledger entry for a human. Requires a human id.
         * @param {string} credit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditCreditLedgerLatestGet(credit: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.apiV1CreditCreditLedgerLatestGet(credit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new credit ledger entry for human. Requires a human id.
         * @summary Create a new credit ledger entry
         * @param {string} credit 
         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditCreditLedgerPost(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {
            return localVarFp.apiV1CreditCreditLedgerPost(credit, createCreditLedgerEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of credits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1CreditListGet200Response> {
            return localVarFp.apiV1CreditListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new credit based on the input request data
         * @summary Create a new credit
         * @param {CreateCreditRequest} createCreditRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CreditPost(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {
            return localVarFp.apiV1CreditPost(createCreditRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * 
     * @summary Get a single credit object
     * @param {string} credit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public apiV1CreditCreditGet(credit: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).apiV1CreditCreditGet(credit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest credit ledger entry for a human. Requires a human id.
     * @param {string} credit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public apiV1CreditCreditLedgerLatestGet(credit: string, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).apiV1CreditCreditLedgerLatestGet(credit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new credit ledger entry for human. Requires a human id.
     * @summary Create a new credit ledger entry
     * @param {string} credit 
     * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public apiV1CreditCreditLedgerPost(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).apiV1CreditCreditLedgerPost(credit, createCreditLedgerEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of credits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public apiV1CreditListGet(options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).apiV1CreditListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new credit based on the input request data
     * @summary Create a new credit
     * @param {CreateCreditRequest} createCreditRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public apiV1CreditPost(createCreditRequest: CreateCreditRequest, options?: RawAxiosRequestConfig) {
        return CreditApiFp(this.configuration).apiV1CreditPost(createCreditRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InferenceApi - axios parameter creator
 * @export
 */
export const InferenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ApiV1ChatCompletionsPostRequest} apiV1ChatCompletionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChatCompletionsPost: async (apiV1ChatCompletionsPostRequest: ApiV1ChatCompletionsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ChatCompletionsPostRequest' is not null or undefined
            assertParamExists('apiV1ChatCompletionsPost', 'apiV1ChatCompletionsPostRequest', apiV1ChatCompletionsPostRequest)
            const localVarPath = `/api/v1/chat/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ChatCompletionsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InferenceApi - functional programming interface
 * @export
 */
export const InferenceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InferenceApiAxiosParamCreator(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ApiV1ChatCompletionsPostRequest} apiV1ChatCompletionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ChatCompletionsPost(apiV1ChatCompletionsPostRequest: ApiV1ChatCompletionsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ChatCompletionsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ChatCompletionsPost(apiV1ChatCompletionsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InferenceApi.apiV1ChatCompletionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InferenceApi - factory interface
 * @export
 */
export const InferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InferenceApiFp(configuration)
    return {
        /**
         * Given messages, generates LLM output text and optionally speech
         * @summary Chat Completions (+ Voice)
         * @param {ApiV1ChatCompletionsPostRequest} apiV1ChatCompletionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ChatCompletionsPost(apiV1ChatCompletionsPostRequest: ApiV1ChatCompletionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ChatCompletionsPost200Response> {
            return localVarFp.apiV1ChatCompletionsPost(apiV1ChatCompletionsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InferenceApi - object-oriented interface
 * @export
 * @class InferenceApi
 * @extends {BaseAPI}
 */
export class InferenceApi extends BaseAPI {
    /**
     * Given messages, generates LLM output text and optionally speech
     * @summary Chat Completions (+ Voice)
     * @param {ApiV1ChatCompletionsPostRequest} apiV1ChatCompletionsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InferenceApi
     */
    public apiV1ChatCompletionsPost(apiV1ChatCompletionsPostRequest: ApiV1ChatCompletionsPostRequest, options?: RawAxiosRequestConfig) {
        return InferenceApiFp(this.configuration).apiV1ChatCompletionsPost(apiV1ChatCompletionsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LLMApi - axios parameter creator
 * @export
 */
export const LLMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LlmListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/llm/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LLMApi - functional programming interface
 * @export
 */
export const LLMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LlmListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1LlmListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LlmListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LLMApi.apiV1LlmListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LLMApi - factory interface
 * @export
 */
export const LLMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LLMApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of llms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LlmListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1LlmListGet200Response> {
            return localVarFp.apiV1LlmListGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LLMApi - object-oriented interface
 * @export
 * @class LLMApi
 * @extends {BaseAPI}
 */
export class LLMApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of llms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    public apiV1LlmListGet(options?: RawAxiosRequestConfig) {
        return LLMApiFp(this.configuration).apiV1LlmListGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/persona/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaPersonaIdDelete: async (personaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('apiV1PersonaPersonaIdDelete', 'personaId', personaId)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaPersonaIdGet: async (personaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('apiV1PersonaPersonaIdGet', 'personaId', personaId)
            const localVarPath = `/api/v1/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonaListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1PersonaListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonaListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiV1PersonaListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonaPersonaIdDelete(personaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1PersonaPersonaIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonaPersonaIdDelete(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiV1PersonaPersonaIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonaPersonaIdGet(personaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonaPersonaIdGet(personaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiV1PersonaPersonaIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1PersonaListGet200Response> {
            return localVarFp.apiV1PersonaListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaPersonaIdDelete(personaId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1PersonaPersonaIdDelete200Response> {
            return localVarFp.apiV1PersonaPersonaIdDelete(personaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a persona
         * @param {string} personaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaPersonaIdGet(personaId: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.apiV1PersonaPersonaIdGet(personaId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of personas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiV1PersonaListGet(options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiV1PersonaListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiV1PersonaPersonaIdDelete(personaId: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiV1PersonaPersonaIdDelete(personaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiV1PersonaPersonaIdGet(personaId: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiV1PersonaPersonaIdGet(personaId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/scenario/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioScenarioIdDelete: async (scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('apiV1ScenarioScenarioIdDelete', 'scenarioId', scenarioId)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioScenarioIdGet: async (scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('apiV1ScenarioScenarioIdGet', 'scenarioId', scenarioId)
            const localVarPath = `/api/v1/scenario/{scenario_id}`
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScenarioListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ScenarioListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ScenarioListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.apiV1ScenarioListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScenarioScenarioIdDelete(scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ScenarioScenarioIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ScenarioScenarioIdDelete(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.apiV1ScenarioScenarioIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScenarioScenarioIdGet(scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ScenarioScenarioIdGet(scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.apiV1ScenarioScenarioIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ScenarioListGet200Response> {
            return localVarFp.apiV1ScenarioListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioScenarioIdDelete(scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ScenarioScenarioIdDelete200Response> {
            return localVarFp.apiV1ScenarioScenarioIdDelete(scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a scenario
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioScenarioIdGet(scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.apiV1ScenarioScenarioIdGet(scenarioId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public apiV1ScenarioListGet(options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).apiV1ScenarioListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public apiV1ScenarioScenarioIdDelete(scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).apiV1ScenarioScenarioIdDelete(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public apiV1ScenarioScenarioIdGet(scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).apiV1ScenarioScenarioIdGet(scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionListGet: async (human?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/session/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (human !== undefined) {
                localVarQueryParameter['human'] = human;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdEndPost', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/end`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdMessagesGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/messages`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut: async (sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'sessionId', sessionId)
            // verify required parameter 'apiV1SessionSessionIdPutRequest' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'apiV1SessionSessionIdPutRequest', apiV1SessionSessionIdPutRequest)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1SessionSessionIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdTimelineGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/timeline`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost: async (apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1SessionStartPostRequest' is not null or undefined
            assertParamExists('apiV1SessionStartPost', 'apiV1SessionStartPostRequest', apiV1SessionStartPostRequest)
            const localVarPath = `/api/v1/session/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1SessionStartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionListGet(human, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdEndPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdTimelineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionStartPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(apiV1SessionStartPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of sessions
         * @param {string} [human] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionListGet200Response> {
            return localVarFp.apiV1SessionListGet(human, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.apiV1SessionSessionIdGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response> {
            return localVarFp.apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response> {
            return localVarFp.apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionStartPost200Response> {
            return localVarFp.apiV1SessionStartPost(apiV1SessionStartPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of sessions
     * @param {string} [human] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionListGet(human?: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionListGet(human, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new session based on the input request data
     * @summary Create a new session
     * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionStartPost(apiV1SessionStartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageLimitsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/usage/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPost: async (apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsageTokenPutRequest' is not null or undefined
            assertParamExists('apiV1UsageTokenPost', 'apiV1UsageTokenPutRequest', apiV1UsageTokenPutRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsageTokenPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPut: async (apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsageTokenPutRequest' is not null or undefined
            assertParamExists('apiV1UsageTokenPut', 'apiV1UsageTokenPutRequest', apiV1UsageTokenPutRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsageTokenPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsageLimitsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UsageTokenPutRequestLimitsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsageLimitsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.apiV1UsageLimitsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsageTokenPost(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsageTokenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsageTokenPost(apiV1UsageTokenPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.apiV1UsageTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsageTokenPut(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsageTokenPut(apiV1UsageTokenPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.apiV1UsageTokenPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageLimitsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UsageTokenPutRequestLimitsInner>> {
            return localVarFp.apiV1UsageLimitsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPost(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsageTokenPost200Response> {
            return localVarFp.apiV1UsageTokenPost(apiV1UsageTokenPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPut(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiV1UsageTokenPut(apiV1UsageTokenPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public apiV1UsageLimitsGet(options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).apiV1UsageLimitsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public apiV1UsageTokenPost(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).apiV1UsageTokenPost(apiV1UsageTokenPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the usage limits of a human
     * @summary Update human usage limits
     * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public apiV1UsageTokenPut(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).apiV1UsageTokenPut(apiV1UsageTokenPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceApi - axios parameter creator
 * @export
 */
export const VoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceClonePost: async (name: string, language: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiV1VoiceClonePost', 'name', name)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('apiV1VoiceClonePost', 'language', language)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiV1VoiceClonePost', 'file', file)
            const localVarPath = `/api/v1/voice/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceGeneratePost: async (apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VoiceGeneratePostRequest' is not null or undefined
            assertParamExists('apiV1VoiceGeneratePost', 'apiV1VoiceGeneratePostRequest', apiV1VoiceGeneratePostRequest)
            const localVarPath = `/api/v1/voice/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VoiceGeneratePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/voice/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews a voice based on the input text
         * @summary Preview a voice
         * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoicePreviewPost: async (apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VoicePreviewPostRequest' is not null or undefined
            assertParamExists('apiV1VoicePreviewPost', 'apiV1VoicePreviewPostRequest', apiV1VoicePreviewPostRequest)
            const localVarPath = `/api/v1/voice/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VoicePreviewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceVoiceIdDelete: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('apiV1VoiceVoiceIdDelete', 'voiceId', voiceId)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {ApiV1VoiceVoiceIdPutRequest} apiV1VoiceVoiceIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceVoiceIdPut: async (voiceId: string, apiV1VoiceVoiceIdPutRequest: ApiV1VoiceVoiceIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voiceId' is not null or undefined
            assertParamExists('apiV1VoiceVoiceIdPut', 'voiceId', voiceId)
            // verify required parameter 'apiV1VoiceVoiceIdPutRequest' is not null or undefined
            assertParamExists('apiV1VoiceVoiceIdPut', 'apiV1VoiceVoiceIdPutRequest', apiV1VoiceVoiceIdPutRequest)
            const localVarPath = `/api/v1/voice/{voice_id}`
                .replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VoiceVoiceIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceApi - functional programming interface
 * @export
 */
export const VoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceClonePost(name: string, language: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoiceClonePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceClonePost(name, language, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceGeneratePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoiceListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Previews a voice based on the input text
         * @summary Preview a voice
         * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoicePreviewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceVoiceIdDelete(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoiceVoiceIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceVoiceIdDelete(voiceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceVoiceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {ApiV1VoiceVoiceIdPutRequest} apiV1VoiceVoiceIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceVoiceIdPut(voiceId: string, apiV1VoiceVoiceIdPutRequest: ApiV1VoiceVoiceIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoiceVoiceIdPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceVoiceIdPut(voiceId, apiV1VoiceVoiceIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceVoiceIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceApi - factory interface
 * @export
 */
export const VoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceApiFp(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceClonePost(name: string, language: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoiceClonePost200Response> {
            return localVarFp.apiV1VoiceClonePost(name, language, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates speech from input text and specified voice
         * @summary Generate voice
         * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoiceListGet200Response> {
            return localVarFp.apiV1VoiceListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Previews a voice based on the input text
         * @summary Preview a voice
         * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a voice
         * @param {string} voiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceVoiceIdDelete(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoiceVoiceIdDelete200Response> {
            return localVarFp.apiV1VoiceVoiceIdDelete(voiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a voice based on the input request data
         * @summary Update a voice
         * @param {string} voiceId 
         * @param {ApiV1VoiceVoiceIdPutRequest} apiV1VoiceVoiceIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceVoiceIdPut(voiceId: string, apiV1VoiceVoiceIdPutRequest: ApiV1VoiceVoiceIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoiceVoiceIdPut200Response> {
            return localVarFp.apiV1VoiceVoiceIdPut(voiceId, apiV1VoiceVoiceIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceApi - object-oriented interface
 * @export
 * @class VoiceApi
 * @extends {BaseAPI}
 */
export class VoiceApi extends BaseAPI {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceClonePost(name: string, language: string, file: File, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceClonePost(name, language, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of voices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceListGet(options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Previews a voice based on the input text
     * @summary Preview a voice
     * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceVoiceIdDelete(voiceId: string, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceVoiceIdDelete(voiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {ApiV1VoiceVoiceIdPutRequest} apiV1VoiceVoiceIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceVoiceIdPut(voiceId: string, apiV1VoiceVoiceIdPutRequest: ApiV1VoiceVoiceIdPutRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceVoiceIdPut(voiceId, apiV1VoiceVoiceIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



